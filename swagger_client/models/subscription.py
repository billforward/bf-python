# coding: utf-8

"""
    BillForward REST API


    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from pprint import pformat
from six import iteritems
import re


class Subscription(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """
    def __init__(self, created=None, changed_by=None, updated=None, metadata=None, id=None, version_id=None, crm_id=None, account_id=None, organization_id=None, product_id=None, product_rate_plan_id=None, parent_id=None, name=None, description=None, type=None, state=None, current_period_start=None, current_period_end=None, contract_start=None, subscription_end=None, current_period_end_explicit=None, initial_period_start=None, successful_periods=None, total_periods=None, trial_end=None, dunning=False, locked=None, managed_by=None, version_start=None, version_end=None, version_number=None, credit_enabled=False, aggregate_all_subscriptions_on_account=False, pricing_component_values=None, payment_method_subscription_links=None, fixed_terms=None, current_time=None, time_offset=None, payment_terms=None, failed_payment_behaviour=None):
        """
        Subscription - a model defined in Swagger

        :param dict swaggerTypes: The key is attribute name
                                  and the value is attribute type.
        :param dict attributeMap: The key is attribute name
                                  and the value is json key in definition.
        """
        self.swagger_types = {
            'created': 'datetime',
            'changed_by': 'str',
            'updated': 'datetime',
            'metadata': 'DynamicMetadata',
            'id': 'str',
            'version_id': 'str',
            'crm_id': 'str',
            'account_id': 'str',
            'organization_id': 'str',
            'product_id': 'str',
            'product_rate_plan_id': 'str',
            'parent_id': 'str',
            'name': 'str',
            'description': 'str',
            'type': 'str',
            'state': 'str',
            'current_period_start': 'datetime',
            'current_period_end': 'datetime',
            'contract_start': 'datetime',
            'subscription_end': 'datetime',
            'current_period_end_explicit': 'datetime',
            'initial_period_start': 'datetime',
            'successful_periods': 'int',
            'total_periods': 'int',
            'trial_end': 'datetime',
            'dunning': 'bool',
            'locked': 'str',
            'managed_by': 'str',
            'version_start': 'datetime',
            'version_end': 'datetime',
            'version_number': 'int',
            'credit_enabled': 'bool',
            'aggregate_all_subscriptions_on_account': 'bool',
            'pricing_component_values': 'list[PricingComponentValue]',
            'payment_method_subscription_links': 'list[PaymentMethodSubscriptionLink]',
            'fixed_terms': 'list[FixedTerm]',
            'current_time': 'datetime',
            'time_offset': 'int',
            'payment_terms': 'int',
            'failed_payment_behaviour': 'str'
        }

        self.attribute_map = {
            'created': 'created',
            'changed_by': 'changedBy',
            'updated': 'updated',
            'metadata': 'metadata',
            'id': 'id',
            'version_id': 'versionID',
            'crm_id': 'crmID',
            'account_id': 'accountID',
            'organization_id': 'organizationID',
            'product_id': 'productID',
            'product_rate_plan_id': 'productRatePlanID',
            'parent_id': 'parentID',
            'name': 'name',
            'description': 'description',
            'type': 'type',
            'state': 'state',
            'current_period_start': 'currentPeriodStart',
            'current_period_end': 'currentPeriodEnd',
            'contract_start': 'contractStart',
            'subscription_end': 'subscriptionEnd',
            'current_period_end_explicit': 'currentPeriodEndExplicit',
            'initial_period_start': 'initialPeriodStart',
            'successful_periods': 'successfulPeriods',
            'total_periods': 'totalPeriods',
            'trial_end': 'trialEnd',
            'dunning': 'dunning',
            'locked': 'locked',
            'managed_by': 'managedBy',
            'version_start': 'versionStart',
            'version_end': 'versionEnd',
            'version_number': 'versionNumber',
            'credit_enabled': 'creditEnabled',
            'aggregate_all_subscriptions_on_account': 'aggregateAllSubscriptionsOnAccount',
            'pricing_component_values': 'pricingComponentValues',
            'payment_method_subscription_links': 'paymentMethodSubscriptionLinks',
            'fixed_terms': 'fixedTerms',
            'current_time': 'currentTime',
            'time_offset': 'timeOffset',
            'payment_terms': 'paymentTerms',
            'failed_payment_behaviour': 'failedPaymentBehaviour'
        }

        self._created = created
        self._changed_by = changed_by
        self._updated = updated
        self._metadata = metadata
        self._id = id
        self._version_id = version_id
        self._crm_id = crm_id
        self._account_id = account_id
        self._organization_id = organization_id
        self._product_id = product_id
        self._product_rate_plan_id = product_rate_plan_id
        self._parent_id = parent_id
        self._name = name
        self._description = description
        self._type = type
        self._state = state
        self._current_period_start = current_period_start
        self._current_period_end = current_period_end
        self._contract_start = contract_start
        self._subscription_end = subscription_end
        self._current_period_end_explicit = current_period_end_explicit
        self._initial_period_start = initial_period_start
        self._successful_periods = successful_periods
        self._total_periods = total_periods
        self._trial_end = trial_end
        self._dunning = dunning
        self._locked = locked
        self._managed_by = managed_by
        self._version_start = version_start
        self._version_end = version_end
        self._version_number = version_number
        self._credit_enabled = credit_enabled
        self._aggregate_all_subscriptions_on_account = aggregate_all_subscriptions_on_account
        self._pricing_component_values = pricing_component_values
        self._payment_method_subscription_links = payment_method_subscription_links
        self._fixed_terms = fixed_terms
        self._current_time = current_time
        self._time_offset = time_offset
        self._payment_terms = payment_terms
        self._failed_payment_behaviour = failed_payment_behaviour

    @property
    def created(self):
        """
        Gets the created of this Subscription.
        { \"description\" : \"The UTC DateTime when the object was created.\", \"verbs\":[] }

        :return: The created of this Subscription.
        :rtype: datetime
        """
        return self._created

    @created.setter
    def created(self, created):
        """
        Sets the created of this Subscription.
        { \"description\" : \"The UTC DateTime when the object was created.\", \"verbs\":[] }

        :param created: The created of this Subscription.
        :type: datetime
        """

        self._created = created

    @property
    def changed_by(self):
        """
        Gets the changed_by of this Subscription.
        { \"description\" : \"ID of the user who last updated the entity.\", \"verbs\":[] }

        :return: The changed_by of this Subscription.
        :rtype: str
        """
        return self._changed_by

    @changed_by.setter
    def changed_by(self, changed_by):
        """
        Sets the changed_by of this Subscription.
        { \"description\" : \"ID of the user who last updated the entity.\", \"verbs\":[] }

        :param changed_by: The changed_by of this Subscription.
        :type: str
        """

        self._changed_by = changed_by

    @property
    def updated(self):
        """
        Gets the updated of this Subscription.
        { \"description\" : \"The UTC DateTime when the object was last updated.\", \"verbs\":[] }

        :return: The updated of this Subscription.
        :rtype: datetime
        """
        return self._updated

    @updated.setter
    def updated(self, updated):
        """
        Sets the updated of this Subscription.
        { \"description\" : \"The UTC DateTime when the object was last updated.\", \"verbs\":[] }

        :param updated: The updated of this Subscription.
        :type: datetime
        """

        self._updated = updated

    @property
    def metadata(self):
        """
        Gets the metadata of this Subscription.
        { \"description\" : \"Add metadata.\", \"verbs\":[\"POST\"] }

        :return: The metadata of this Subscription.
        :rtype: DynamicMetadata
        """
        return self._metadata

    @metadata.setter
    def metadata(self, metadata):
        """
        Sets the metadata of this Subscription.
        { \"description\" : \"Add metadata.\", \"verbs\":[\"POST\"] }

        :param metadata: The metadata of this Subscription.
        :type: DynamicMetadata
        """

        self._metadata = metadata

    @property
    def id(self):
        """
        Gets the id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"GET\"]}

        :return: The id of this Subscription.
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """
        Sets the id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"GET\"]}

        :param id: The id of this Subscription.
        :type: str
        """

        self._id = id

    @property
    def version_id(self):
        """
        Gets the version_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"GET\"]}

        :return: The version_id of this Subscription.
        :rtype: str
        """
        return self._version_id

    @version_id.setter
    def version_id(self, version_id):
        """
        Sets the version_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"GET\"]}

        :param version_id: The version_id of this Subscription.
        :type: str
        """

        self._version_id = version_id

    @property
    def crm_id(self):
        """
        Gets the crm_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :return: The crm_id of this Subscription.
        :rtype: str
        """
        return self._crm_id

    @crm_id.setter
    def crm_id(self, crm_id):
        """
        Sets the crm_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :param crm_id: The crm_id of this Subscription.
        :type: str
        """

        self._crm_id = crm_id

    @property
    def account_id(self):
        """
        Gets the account_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The account_id of this Subscription.
        :rtype: str
        """
        return self._account_id

    @account_id.setter
    def account_id(self, account_id):
        """
        Sets the account_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"POST\",\"GET\"]}

        :param account_id: The account_id of this Subscription.
        :type: str
        """

        self._account_id = account_id

    @property
    def organization_id(self):
        """
        Gets the organization_id of this Subscription.
        {\"description\":\"Organization associated with the subscription.\",\"verbs\":[]}

        :return: The organization_id of this Subscription.
        :rtype: str
        """
        return self._organization_id

    @organization_id.setter
    def organization_id(self, organization_id):
        """
        Sets the organization_id of this Subscription.
        {\"description\":\"Organization associated with the subscription.\",\"verbs\":[]}

        :param organization_id: The organization_id of this Subscription.
        :type: str
        """

        self._organization_id = organization_id

    @property
    def product_id(self):
        """
        Gets the product_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"GET\"]}

        :return: The product_id of this Subscription.
        :rtype: str
        """
        return self._product_id

    @product_id.setter
    def product_id(self, product_id):
        """
        Sets the product_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"GET\"]}

        :param product_id: The product_id of this Subscription.
        :type: str
        """

        self._product_id = product_id

    @property
    def product_rate_plan_id(self):
        """
        Gets the product_rate_plan_id of this Subscription.
        {\"description\":\"Identifier of the rate-plan being billed for.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :return: The product_rate_plan_id of this Subscription.
        :rtype: str
        """
        return self._product_rate_plan_id

    @product_rate_plan_id.setter
    def product_rate_plan_id(self, product_rate_plan_id):
        """
        Sets the product_rate_plan_id of this Subscription.
        {\"description\":\"Identifier of the rate-plan being billed for.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :param product_rate_plan_id: The product_rate_plan_id of this Subscription.
        :type: str
        """

        self._product_rate_plan_id = product_rate_plan_id

    @property
    def parent_id(self):
        """
        Gets the parent_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"GET\"]}

        :return: The parent_id of this Subscription.
        :rtype: str
        """
        return self._parent_id

    @parent_id.setter
    def parent_id(self, parent_id):
        """
        Sets the parent_id of this Subscription.
        {\"description\":\"\",\"verbs\":[\"GET\"]}

        :param parent_id: The parent_id of this Subscription.
        :type: str
        """

        self._parent_id = parent_id

    @property
    def name(self):
        """
        Gets the name of this Subscription.
        {\"description\":\"User definable friendly name for the subscription.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :return: The name of this Subscription.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """
        Sets the name of this Subscription.
        {\"description\":\"User definable friendly name for the subscription.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :param name: The name of this Subscription.
        :type: str
        """

        self._name = name

    @property
    def description(self):
        """
        Gets the description of this Subscription.
        {\"description\":\"\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :return: The description of this Subscription.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """
        Sets the description of this Subscription.
        {\"description\":\"\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :param description: The description of this Subscription.
        :type: str
        """

        self._description = description

    @property
    def type(self):
        """
        Gets the type of this Subscription.
        {\"default\":\"dependent on product\", \"description\":\"\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The type of this Subscription.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """
        Sets the type of this Subscription.
        {\"default\":\"dependent on product\", \"description\":\"\",\"verbs\":[\"POST\",\"GET\"]}

        :param type: The type of this Subscription.
        :type: str
        """
        allowed_values = ["Subscription", "FixedTerm", "Trial"]
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def state(self):
        """
        Gets the state of this Subscription.
        {\"PUT_description\":\"A <span class=\\\"label label-default\\\">Provisioned</span> subscription can be updated to either <span class=\\\"label label-default\\\">Trial</span> or <span class=\\\"label label-default\\\">AwaitingPayment</span>, this will start the subscription. Any updates to the state of a non-<span class=\\\"label label-default\\\">Provisioned</span> will be ignored. To cancel or otherwise amend a subscription please use the explict amendment calls.\", \"description\":\"A <span class=\\\"label label-default\\\">Provisioned</span> subscription will not begin until marked as <span class=\\\"label label-default\\\">Trial</span> or <span class=\\\"label label-default\\\">AwaitingPayment</span>. Trial subscriptions transition to <span class=\\\"label label-default\\\">AwaitingPayment</span> when the trial period is over. On subscription renewal the state becomes <span class=\\\"label label-default\\\">AwaitingPayment</span>. Once outstanding invoices are paid the state changes to <span class=\\\"label label-default\\\">Paid</span>. A subscription is set as either <span class=\\\"label label-default\\\">Failed</span> or left as <span class=\\\"label label-default\\\">AwaitingPayment</span>, depending on the rate-plan configuration. If a subscription is non-recurring or fixed-term and ends naturally, it will be marked as <span class=\\\"label label-default\\\">Expired</span>. If all payment attempts have failed a subscription is marked as <span class=\\\"label label-default\\\">Cancelled</span> if it has been manually ended. Once a subscription is marked as <span class=\\\"label label-default\\\">Failed</span>, <span class=\\\"label label-default\\\">Expired</span>, or <span class=\\\"label label-default\\\">Cancelled</span> no invoices other than a final invoice will be issued. Note: Updating account card details will not lead to BillForward automatically retrying payment, manual payment attempts can be made.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :return: The state of this Subscription.
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """
        Sets the state of this Subscription.
        {\"PUT_description\":\"A <span class=\\\"label label-default\\\">Provisioned</span> subscription can be updated to either <span class=\\\"label label-default\\\">Trial</span> or <span class=\\\"label label-default\\\">AwaitingPayment</span>, this will start the subscription. Any updates to the state of a non-<span class=\\\"label label-default\\\">Provisioned</span> will be ignored. To cancel or otherwise amend a subscription please use the explict amendment calls.\", \"description\":\"A <span class=\\\"label label-default\\\">Provisioned</span> subscription will not begin until marked as <span class=\\\"label label-default\\\">Trial</span> or <span class=\\\"label label-default\\\">AwaitingPayment</span>. Trial subscriptions transition to <span class=\\\"label label-default\\\">AwaitingPayment</span> when the trial period is over. On subscription renewal the state becomes <span class=\\\"label label-default\\\">AwaitingPayment</span>. Once outstanding invoices are paid the state changes to <span class=\\\"label label-default\\\">Paid</span>. A subscription is set as either <span class=\\\"label label-default\\\">Failed</span> or left as <span class=\\\"label label-default\\\">AwaitingPayment</span>, depending on the rate-plan configuration. If a subscription is non-recurring or fixed-term and ends naturally, it will be marked as <span class=\\\"label label-default\\\">Expired</span>. If all payment attempts have failed a subscription is marked as <span class=\\\"label label-default\\\">Cancelled</span> if it has been manually ended. Once a subscription is marked as <span class=\\\"label label-default\\\">Failed</span>, <span class=\\\"label label-default\\\">Expired</span>, or <span class=\\\"label label-default\\\">Cancelled</span> no invoices other than a final invoice will be issued. Note: Updating account card details will not lead to BillForward automatically retrying payment, manual payment attempts can be made.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :param state: The state of this Subscription.
        :type: str
        """
        allowed_values = ["Trial", "Provisioned", "Paid", "AwaitingPayment", "Cancelled", "Failed", "Expired"]
        if state not in allowed_values:
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def current_period_start(self):
        """
        Gets the current_period_start of this Subscription.
        {\"description\":\"Start of the current invoice period. At the end of this period, a new new invoice will be generated\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The current_period_start of this Subscription.
        :rtype: datetime
        """
        return self._current_period_start

    @current_period_start.setter
    def current_period_start(self, current_period_start):
        """
        Sets the current_period_start of this Subscription.
        {\"description\":\"Start of the current invoice period. At the end of this period, a new new invoice will be generated\",\"verbs\":[\"POST\",\"GET\"]}

        :param current_period_start: The current_period_start of this Subscription.
        :type: datetime
        """

        self._current_period_start = current_period_start

    @property
    def current_period_end(self):
        """
        Gets the current_period_end of this Subscription.
        {\"description\":\"End of the current period invoiced for. This can be manually updated to extend trials or delay invoice generation.\",\"verbs\":[\"PUT\",\"GET\"]}

        :return: The current_period_end of this Subscription.
        :rtype: datetime
        """
        return self._current_period_end

    @current_period_end.setter
    def current_period_end(self, current_period_end):
        """
        Sets the current_period_end of this Subscription.
        {\"description\":\"End of the current period invoiced for. This can be manually updated to extend trials or delay invoice generation.\",\"verbs\":[\"PUT\",\"GET\"]}

        :param current_period_end: The current_period_end of this Subscription.
        :type: datetime
        """

        self._current_period_end = current_period_end

    @property
    def contract_start(self):
        """
        Gets the contract_start of this Subscription.
        {\"description\":\"start of the contracted period.  This will be after a trial, if one exists\",\"verbs\":[\"GET\"]}

        :return: The contract_start of this Subscription.
        :rtype: datetime
        """
        return self._contract_start

    @contract_start.setter
    def contract_start(self, contract_start):
        """
        Sets the contract_start of this Subscription.
        {\"description\":\"start of the contracted period.  This will be after a trial, if one exists\",\"verbs\":[\"GET\"]}

        :param contract_start: The contract_start of this Subscription.
        :type: datetime
        """

        self._contract_start = contract_start

    @property
    def subscription_end(self):
        """
        Gets the subscription_end of this Subscription.
        {\"description\":\"When a subscription will end. This may be in the future if the cancellation is at the end of the current period.\",\"verbs\":[\"GET\"]}

        :return: The subscription_end of this Subscription.
        :rtype: datetime
        """
        return self._subscription_end

    @subscription_end.setter
    def subscription_end(self, subscription_end):
        """
        Sets the subscription_end of this Subscription.
        {\"description\":\"When a subscription will end. This may be in the future if the cancellation is at the end of the current period.\",\"verbs\":[\"GET\"]}

        :param subscription_end: The subscription_end of this Subscription.
        :type: datetime
        """

        self._subscription_end = subscription_end

    @property
    def current_period_end_explicit(self):
        """
        Gets the current_period_end_explicit of this Subscription.
        {\"description\":\"Override for the initial subscription period. Allows periods to align to a date or time regardless of purchase date/time.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :return: The current_period_end_explicit of this Subscription.
        :rtype: datetime
        """
        return self._current_period_end_explicit

    @current_period_end_explicit.setter
    def current_period_end_explicit(self, current_period_end_explicit):
        """
        Sets the current_period_end_explicit of this Subscription.
        {\"description\":\"Override for the initial subscription period. Allows periods to align to a date or time regardless of purchase date/time.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :param current_period_end_explicit: The current_period_end_explicit of this Subscription.
        :type: datetime
        """

        self._current_period_end_explicit = current_period_end_explicit

    @property
    def initial_period_start(self):
        """
        Gets the initial_period_start of this Subscription.
        {\"description\":\"Start of the first successful period\",\"verbs\":[\"GET\"]}

        :return: The initial_period_start of this Subscription.
        :rtype: datetime
        """
        return self._initial_period_start

    @initial_period_start.setter
    def initial_period_start(self, initial_period_start):
        """
        Sets the initial_period_start of this Subscription.
        {\"description\":\"Start of the first successful period\",\"verbs\":[\"GET\"]}

        :param initial_period_start: The initial_period_start of this Subscription.
        :type: datetime
        """

        self._initial_period_start = initial_period_start

    @property
    def successful_periods(self):
        """
        Gets the successful_periods of this Subscription.
        {\"description\":\"Number of paid-for periods billing, excluding trials, since the subscription started.\",\"verbs\":[\"GET\"]}

        :return: The successful_periods of this Subscription.
        :rtype: int
        """
        return self._successful_periods

    @successful_periods.setter
    def successful_periods(self, successful_periods):
        """
        Sets the successful_periods of this Subscription.
        {\"description\":\"Number of paid-for periods billing, excluding trials, since the subscription started.\",\"verbs\":[\"GET\"]}

        :param successful_periods: The successful_periods of this Subscription.
        :type: int
        """

        self._successful_periods = successful_periods

    @property
    def total_periods(self):
        """
        Gets the total_periods of this Subscription.
        {\"description\":\"Total number of subscription periods.\",\"verbs\":[\"GET\"]}

        :return: The total_periods of this Subscription.
        :rtype: int
        """
        return self._total_periods

    @total_periods.setter
    def total_periods(self, total_periods):
        """
        Sets the total_periods of this Subscription.
        {\"description\":\"Total number of subscription periods.\",\"verbs\":[\"GET\"]}

        :param total_periods: The total_periods of this Subscription.
        :type: int
        """

        self._total_periods = total_periods

    @property
    def trial_end(self):
        """
        Gets the trial_end of this Subscription.
        {\"description\":\"The end time of the trial period, if one existed\",\"verbs\":[\"GET\"]}

        :return: The trial_end of this Subscription.
        :rtype: datetime
        """
        return self._trial_end

    @trial_end.setter
    def trial_end(self, trial_end):
        """
        Sets the trial_end of this Subscription.
        {\"description\":\"The end time of the trial period, if one existed\",\"verbs\":[\"GET\"]}

        :param trial_end: The trial_end of this Subscription.
        :type: datetime
        """

        self._trial_end = trial_end

    @property
    def dunning(self):
        """
        Gets the dunning of this Subscription.
        {  \"default\":\"false\", \"description\":\"Are there outstanding invoices which are currently in dunning.\",\"verbs\":[\"GET\", \"PUT\", \"POST\"]}

        :return: The dunning of this Subscription.
        :rtype: bool
        """
        return self._dunning

    @dunning.setter
    def dunning(self, dunning):
        """
        Sets the dunning of this Subscription.
        {  \"default\":\"false\", \"description\":\"Are there outstanding invoices which are currently in dunning.\",\"verbs\":[\"GET\", \"PUT\", \"POST\"]}

        :param dunning: The dunning of this Subscription.
        :type: bool
        """

        self._dunning = dunning

    @property
    def locked(self):
        """
        Gets the locked of this Subscription.
        {\"description\":\"If the subscription is locked, it will not be processed by the system\",\"verbs\":[]}

        :return: The locked of this Subscription.
        :rtype: str
        """
        return self._locked

    @locked.setter
    def locked(self, locked):
        """
        Sets the locked of this Subscription.
        {\"description\":\"If the subscription is locked, it will not be processed by the system\",\"verbs\":[]}

        :param locked: The locked of this Subscription.
        :type: str
        """

        self._locked = locked

    @property
    def managed_by(self):
        """
        Gets the managed_by of this Subscription.
        {\"description\":\"Which system is responsible for managing the subscription.\",\"verbs\":[]}

        :return: The managed_by of this Subscription.
        :rtype: str
        """
        return self._managed_by

    @managed_by.setter
    def managed_by(self, managed_by):
        """
        Sets the managed_by of this Subscription.
        {\"description\":\"Which system is responsible for managing the subscription.\",\"verbs\":[]}

        :param managed_by: The managed_by of this Subscription.
        :type: str
        """
        allowed_values = ["BillForward", "Stripe"]
        if managed_by not in allowed_values:
            raise ValueError(
                "Invalid value for `managed_by` ({0}), must be one of {1}"
                .format(managed_by, allowed_values)
            )

        self._managed_by = managed_by

    @property
    def version_start(self):
        """
        Gets the version_start of this Subscription.
        {\"description\":\"When the current version of the subscription started.\",\"verbs\":[\"GET\"]}

        :return: The version_start of this Subscription.
        :rtype: datetime
        """
        return self._version_start

    @version_start.setter
    def version_start(self, version_start):
        """
        Sets the version_start of this Subscription.
        {\"description\":\"When the current version of the subscription started.\",\"verbs\":[\"GET\"]}

        :param version_start: The version_start of this Subscription.
        :type: datetime
        """

        self._version_start = version_start

    @property
    def version_end(self):
        """
        Gets the version_end of this Subscription.
        {\"description\":\"When the current version of the subscription ended, null indicates current version.\",\"verbs\":[\"GET\"]}

        :return: The version_end of this Subscription.
        :rtype: datetime
        """
        return self._version_end

    @version_end.setter
    def version_end(self, version_end):
        """
        Sets the version_end of this Subscription.
        {\"description\":\"When the current version of the subscription ended, null indicates current version.\",\"verbs\":[\"GET\"]}

        :param version_end: The version_end of this Subscription.
        :type: datetime
        """

        self._version_end = version_end

    @property
    def version_number(self):
        """
        Gets the version_number of this Subscription.
        {\"description\":\"Incremental version number of the subscription, starts at 1.\",\"verbs\":[\"GET\"]}

        :return: The version_number of this Subscription.
        :rtype: int
        """
        return self._version_number

    @version_number.setter
    def version_number(self, version_number):
        """
        Sets the version_number of this Subscription.
        {\"description\":\"Incremental version number of the subscription, starts at 1.\",\"verbs\":[\"GET\"]}

        :param version_number: The version_number of this Subscription.
        :type: int
        """

        self._version_number = version_number

    @property
    def credit_enabled(self):
        """
        Gets the credit_enabled of this Subscription.
        {  \"default\":\"true\", \"description\":\"Can credit-notes be used to pay outstanding invoices for this subscription.\",\"verbs\":[\"GET\", \"PUT\", \"POST\"]}

        :return: The credit_enabled of this Subscription.
        :rtype: bool
        """
        return self._credit_enabled

    @credit_enabled.setter
    def credit_enabled(self, credit_enabled):
        """
        Sets the credit_enabled of this Subscription.
        {  \"default\":\"true\", \"description\":\"Can credit-notes be used to pay outstanding invoices for this subscription.\",\"verbs\":[\"GET\", \"PUT\", \"POST\"]}

        :param credit_enabled: The credit_enabled of this Subscription.
        :type: bool
        """

        self._credit_enabled = credit_enabled

    @property
    def aggregate_all_subscriptions_on_account(self):
        """
        Gets the aggregate_all_subscriptions_on_account of this Subscription.
        {  \"default\":\"true\", \"description\":\"Whether the subscription will aggregate all other subscriptions on the account.\",\"verbs\":[\"GET\", \"PUT\", \"POST\"]}

        :return: The aggregate_all_subscriptions_on_account of this Subscription.
        :rtype: bool
        """
        return self._aggregate_all_subscriptions_on_account

    @aggregate_all_subscriptions_on_account.setter
    def aggregate_all_subscriptions_on_account(self, aggregate_all_subscriptions_on_account):
        """
        Sets the aggregate_all_subscriptions_on_account of this Subscription.
        {  \"default\":\"true\", \"description\":\"Whether the subscription will aggregate all other subscriptions on the account.\",\"verbs\":[\"GET\", \"PUT\", \"POST\"]}

        :param aggregate_all_subscriptions_on_account: The aggregate_all_subscriptions_on_account of this Subscription.
        :type: bool
        """

        self._aggregate_all_subscriptions_on_account = aggregate_all_subscriptions_on_account

    @property
    def pricing_component_values(self):
        """
        Gets the pricing_component_values of this Subscription.
        {\"description\":\"The quantities for each pricing component of the rate-plan. Values should be set for all pricing components of the rate-plan apart from the usage components. Usage components should be added when the usage is known, this is often after the end of the current billing cycle.\",\"verbs\":[\"GET\", \"POST\"]}

        :return: The pricing_component_values of this Subscription.
        :rtype: list[PricingComponentValue]
        """
        return self._pricing_component_values

    @pricing_component_values.setter
    def pricing_component_values(self, pricing_component_values):
        """
        Sets the pricing_component_values of this Subscription.
        {\"description\":\"The quantities for each pricing component of the rate-plan. Values should be set for all pricing components of the rate-plan apart from the usage components. Usage components should be added when the usage is known, this is often after the end of the current billing cycle.\",\"verbs\":[\"GET\", \"POST\"]}

        :param pricing_component_values: The pricing_component_values of this Subscription.
        :type: list[PricingComponentValue]
        """

        self._pricing_component_values = pricing_component_values

    @property
    def payment_method_subscription_links(self):
        """
        Gets the payment_method_subscription_links of this Subscription.


        :return: The payment_method_subscription_links of this Subscription.
        :rtype: list[PaymentMethodSubscriptionLink]
        """
        return self._payment_method_subscription_links

    @payment_method_subscription_links.setter
    def payment_method_subscription_links(self, payment_method_subscription_links):
        """
        Sets the payment_method_subscription_links of this Subscription.


        :param payment_method_subscription_links: The payment_method_subscription_links of this Subscription.
        :type: list[PaymentMethodSubscriptionLink]
        """

        self._payment_method_subscription_links = payment_method_subscription_links

    @property
    def fixed_terms(self):
        """
        Gets the fixed_terms of this Subscription.
        {\"description\":\"List of fixed terms that have been or are applied to the subscription\",\"verbs\":[\"GET\"]}

        :return: The fixed_terms of this Subscription.
        :rtype: list[FixedTerm]
        """
        return self._fixed_terms

    @fixed_terms.setter
    def fixed_terms(self, fixed_terms):
        """
        Sets the fixed_terms of this Subscription.
        {\"description\":\"List of fixed terms that have been or are applied to the subscription\",\"verbs\":[\"GET\"]}

        :param fixed_terms: The fixed_terms of this Subscription.
        :type: list[FixedTerm]
        """

        self._fixed_terms = fixed_terms

    @property
    def current_time(self):
        """
        Gets the current_time of this Subscription.
        {\"description\":\"The current time &mdash; from the point of view of the subscription.\",\"verbs\":[\"GET\"]}

        :return: The current_time of this Subscription.
        :rtype: datetime
        """
        return self._current_time

    @current_time.setter
    def current_time(self, current_time):
        """
        Sets the current_time of this Subscription.
        {\"description\":\"The current time &mdash; from the point of view of the subscription.\",\"verbs\":[\"GET\"]}

        :param current_time: The current_time of this Subscription.
        :type: datetime
        """

        self._current_time = current_time

    @property
    def time_offset(self):
        """
        Gets the time_offset of this Subscription.
        {\"description\":\"How far in the future is the entity (in seconds) compared to the BillForward server's time.\",\"verbs\":[\"GET\"]}

        :return: The time_offset of this Subscription.
        :rtype: int
        """
        return self._time_offset

    @time_offset.setter
    def time_offset(self, time_offset):
        """
        Sets the time_offset of this Subscription.
        {\"description\":\"How far in the future is the entity (in seconds) compared to the BillForward server's time.\",\"verbs\":[\"GET\"]}

        :param time_offset: The time_offset of this Subscription.
        :type: int
        """

        self._time_offset = time_offset

    @property
    def payment_terms(self):
        """
        Gets the payment_terms of this Subscription.


        :return: The payment_terms of this Subscription.
        :rtype: int
        """
        return self._payment_terms

    @payment_terms.setter
    def payment_terms(self, payment_terms):
        """
        Sets the payment_terms of this Subscription.


        :param payment_terms: The payment_terms of this Subscription.
        :type: int
        """

        self._payment_terms = payment_terms

    @property
    def failed_payment_behaviour(self):
        """
        Gets the failed_payment_behaviour of this Subscription.
        {\"default\":\"None\",\"description\":\"The action that should be taken, should an invoice for some subscription to this rate plan remain unpaid despite the dunning period's being exceeded.<br><span class=\\\"label label-default\\\">CancelSubscription</span> &mdash; Demotes the subscription to the `Failed` state as soon as the dunning period is exceeded.<br><span class=\\\"label label-default\\\">None</span> &mdash; The subscription is allowed to continue in the `AwaitingPayment` state indefinitely even if the dunning period is exceeded.For slow payment cycles &mdash; or when manual invoice remediation is common &mdash; <span class=\\\"label label-default\\\">None</span> is recommended.<br>In a heavily-automated SaaS environment, automatic cancellation via <span class=\\\"label label-default\\\">CancelSubscription</span> is recommended.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :return: The failed_payment_behaviour of this Subscription.
        :rtype: str
        """
        return self._failed_payment_behaviour

    @failed_payment_behaviour.setter
    def failed_payment_behaviour(self, failed_payment_behaviour):
        """
        Sets the failed_payment_behaviour of this Subscription.
        {\"default\":\"None\",\"description\":\"The action that should be taken, should an invoice for some subscription to this rate plan remain unpaid despite the dunning period's being exceeded.<br><span class=\\\"label label-default\\\">CancelSubscription</span> &mdash; Demotes the subscription to the `Failed` state as soon as the dunning period is exceeded.<br><span class=\\\"label label-default\\\">None</span> &mdash; The subscription is allowed to continue in the `AwaitingPayment` state indefinitely even if the dunning period is exceeded.For slow payment cycles &mdash; or when manual invoice remediation is common &mdash; <span class=\\\"label label-default\\\">None</span> is recommended.<br>In a heavily-automated SaaS environment, automatic cancellation via <span class=\\\"label label-default\\\">CancelSubscription</span> is recommended.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}

        :param failed_payment_behaviour: The failed_payment_behaviour of this Subscription.
        :type: str
        """
        allowed_values = ["CancelSubscription", "None"]
        if failed_payment_behaviour not in allowed_values:
            raise ValueError(
                "Invalid value for `failed_payment_behaviour` ({0}), must be one of {1}"
                .format(failed_payment_behaviour, allowed_values)
            )

        self._failed_payment_behaviour = failed_payment_behaviour

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        return self.to_str()

    def __eq__(self, other):
        """
        Returns true if both objects are equal
        """
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """
        Returns true if both objects are not equal
        """
        return not self == other
