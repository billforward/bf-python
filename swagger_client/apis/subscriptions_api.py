# coding: utf-8

"""
    BillForward REST API


    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class SubscriptionsApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def add_charge_to_subscription(self, subscription_id, charge, **kwargs):
        """
        Creates a charge on the specified subscription.
        {\"nickname\":\"Add Charge\",\"response\":\"addChargeToSubscriptionRequest.html\",\"response\":\"addChargeToSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_charge_to_subscription(subscription_id, charge, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param AddChargeRequest charge: The charge request (required)
        :return: SubscriptionChargePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_charge_to_subscription_with_http_info(subscription_id, charge, **kwargs)
        else:
            (data) = self.add_charge_to_subscription_with_http_info(subscription_id, charge, **kwargs)
            return data

    def add_charge_to_subscription_with_http_info(self, subscription_id, charge, **kwargs):
        """
        Creates a charge on the specified subscription.
        {\"nickname\":\"Add Charge\",\"response\":\"addChargeToSubscriptionRequest.html\",\"response\":\"addChargeToSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_charge_to_subscription_with_http_info(subscription_id, charge, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param AddChargeRequest charge: The charge request (required)
        :return: SubscriptionChargePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'charge']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_charge_to_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `add_charge_to_subscription`")
        # verify the required parameter 'charge' is set
        if ('charge' not in params) or (params['charge'] is None):
            raise ValueError("Missing the required parameter `charge` when calling `add_charge_to_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/charge'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'charge' in params:
            body_params = params['charge']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionChargePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_coupon_to_subscription(self, subscription_id, request, **kwargs):
        """
        Applies a coupon to a subscription.
        {\"nickname\":\"Apply coupon\", \"request\":\"addCouponCodeRequest.html\",\"response\":\"addCouponCodeResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_coupon_to_subscription(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param AddCouponCodeRequest request: Request containing the coupon code. (required)
        :return: CouponPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_coupon_to_subscription_with_http_info(subscription_id, request, **kwargs)
        else:
            (data) = self.add_coupon_to_subscription_with_http_info(subscription_id, request, **kwargs)
            return data

    def add_coupon_to_subscription_with_http_info(self, subscription_id, request, **kwargs):
        """
        Applies a coupon to a subscription.
        {\"nickname\":\"Apply coupon\", \"request\":\"addCouponCodeRequest.html\",\"response\":\"addCouponCodeResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_coupon_to_subscription_with_http_info(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param AddCouponCodeRequest request: Request containing the coupon code. (required)
        :return: CouponPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_coupon_to_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `add_coupon_to_subscription`")
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `add_coupon_to_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/coupons'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='CouponPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_credit_note_to_subscription(self, subscription_id, credit_note, **kwargs):
        """
        Creates a credit-note which may be used by only the specified subscription.
        {\"nickname\":\"Add Credit\",\"request\":\"addCreditNoteToSubscriptionRequest.html\", \"response\":\"addCreditNoteToSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_credit_note_to_subscription(subscription_id, credit_note, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param CreditSubscriptionRequest credit_note: The credit-note request (required)
        :return: CreditNotePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_credit_note_to_subscription_with_http_info(subscription_id, credit_note, **kwargs)
        else:
            (data) = self.add_credit_note_to_subscription_with_http_info(subscription_id, credit_note, **kwargs)
            return data

    def add_credit_note_to_subscription_with_http_info(self, subscription_id, credit_note, **kwargs):
        """
        Creates a credit-note which may be used by only the specified subscription.
        {\"nickname\":\"Add Credit\",\"request\":\"addCreditNoteToSubscriptionRequest.html\", \"response\":\"addCreditNoteToSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_credit_note_to_subscription_with_http_info(subscription_id, credit_note, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param CreditSubscriptionRequest credit_note: The credit-note request (required)
        :return: CreditNotePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'credit_note']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_credit_note_to_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `add_credit_note_to_subscription`")
        # verify the required parameter 'credit_note' is set
        if ('credit_note' not in params) or (params['credit_note'] is None):
            raise ValueError("Missing the required parameter `credit_note` when calling `add_credit_note_to_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/credit'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'credit_note' in params:
            body_params = params['credit_note']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='CreditNotePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def add_payment_method_to_subscription(self, subscription_id, payment_method, **kwargs):
        """
        Enables the payment method to pay invoices of this subscription.
        {\"nickname\":\"Add payment-method to subscription\",\"response\":\"addPaymentMethod.html\",\"request\":\"addPaymentMethod.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_payment_method_to_subscription(subscription_id, payment_method, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param AddPaymentMethodRequest payment_method:  (required)
        :return: PaymentMethodPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_payment_method_to_subscription_with_http_info(subscription_id, payment_method, **kwargs)
        else:
            (data) = self.add_payment_method_to_subscription_with_http_info(subscription_id, payment_method, **kwargs)
            return data

    def add_payment_method_to_subscription_with_http_info(self, subscription_id, payment_method, **kwargs):
        """
        Enables the payment method to pay invoices of this subscription.
        {\"nickname\":\"Add payment-method to subscription\",\"response\":\"addPaymentMethod.html\",\"request\":\"addPaymentMethod.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_payment_method_to_subscription_with_http_info(subscription_id, payment_method, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param AddPaymentMethodRequest payment_method:  (required)
        :return: PaymentMethodPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'payment_method']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_payment_method_to_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `add_payment_method_to_subscription`")
        # verify the required parameter 'payment_method' is set
        if ('payment_method' not in params) or (params['payment_method'] is None):
            raise ValueError("Missing the required parameter `payment_method` when calling `add_payment_method_to_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/payment-methods'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payment_method' in params:
            body_params = params['payment_method']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PaymentMethodPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def advance_subscription(self, subscription_id, request, **kwargs):
        """
        Advance the subscription through time.
        {\"nickname\":\"Advance\",\"request\":\"advanceSubscriptionRequest.html\",\"response\":\"advanceSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.advance_subscription(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param TimeRequest request: The request (required)
        :return: TimeResponsePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.advance_subscription_with_http_info(subscription_id, request, **kwargs)
        else:
            (data) = self.advance_subscription_with_http_info(subscription_id, request, **kwargs)
            return data

    def advance_subscription_with_http_info(self, subscription_id, request, **kwargs):
        """
        Advance the subscription through time.
        {\"nickname\":\"Advance\",\"request\":\"advanceSubscriptionRequest.html\",\"response\":\"advanceSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.advance_subscription_with_http_info(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param TimeRequest request: The request (required)
        :return: TimeResponsePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method advance_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `advance_subscription`")
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `advance_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/advance'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TimeResponsePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def available_payment_methods_for_subscription(self, subscription_id, **kwargs):
        """
        Returns all available payment methods for the specified subscription. By default 10 values are returned. Records are returned in natural order.
        { \"nickname\" : \"List on subscription\",\"response\" : \"getAvailablePaymentMethods.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.available_payment_methods_for_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: PaymentMethodPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.available_payment_methods_for_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.available_payment_methods_for_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def available_payment_methods_for_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Returns all available payment methods for the specified subscription. By default 10 values are returned. Records are returned in natural order.
        { \"nickname\" : \"List on subscription\",\"response\" : \"getAvailablePaymentMethods.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.available_payment_methods_for_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: PaymentMethodPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations', 'offset', 'records', 'order_by', 'order']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method available_payment_methods_for_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `available_payment_methods_for_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/payment-methods'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PaymentMethodPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def batch_create_subscriptions(self, request, **kwargs):
        """
        Create multiple subscriptions.
        {\"nickname\":\"Create multiple subscriptions\",\"response\":\"createMultipleSubscriptionViaHelper.html\",\"request\":\"createMultipleSubscriptionViaHelper.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_create_subscriptions(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateSubscriptionBatchRequest request:  (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.batch_create_subscriptions_with_http_info(request, **kwargs)
        else:
            (data) = self.batch_create_subscriptions_with_http_info(request, **kwargs)
            return data

    def batch_create_subscriptions_with_http_info(self, request, **kwargs):
        """
        Create multiple subscriptions.
        {\"nickname\":\"Create multiple subscriptions\",\"response\":\"createMultipleSubscriptionViaHelper.html\",\"request\":\"createMultipleSubscriptionViaHelper.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.batch_create_subscriptions_with_http_info(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateSubscriptionBatchRequest request:  (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_create_subscriptions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `batch_create_subscriptions`")

        resource_path = '/subscriptions/batch'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def cancel_subscription(self, subscription_id, subscription_cancellation, **kwargs):
        """
        Retires the subscription specified by the subscription-ID parameter. Retiring a subscription causes it to cancel based on the specified retirement settings for the product.
        {\"nickname\":\"Cancel subscription\",\"response\":\"deleteSubscription.html\",\"request\":\"deleteSubscriptionRequest.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_subscription(subscription_id, subscription_cancellation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param CancelSubscriptionRequest subscription_cancellation: The cancellation request (required)
        :return: SubscriptionCancellationPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.cancel_subscription_with_http_info(subscription_id, subscription_cancellation, **kwargs)
        else:
            (data) = self.cancel_subscription_with_http_info(subscription_id, subscription_cancellation, **kwargs)
            return data

    def cancel_subscription_with_http_info(self, subscription_id, subscription_cancellation, **kwargs):
        """
        Retires the subscription specified by the subscription-ID parameter. Retiring a subscription causes it to cancel based on the specified retirement settings for the product.
        {\"nickname\":\"Cancel subscription\",\"response\":\"deleteSubscription.html\",\"request\":\"deleteSubscriptionRequest.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_subscription_with_http_info(subscription_id, subscription_cancellation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param CancelSubscriptionRequest subscription_cancellation: The cancellation request (required)
        :return: SubscriptionCancellationPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'subscription_cancellation']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `cancel_subscription`")
        # verify the required parameter 'subscription_cancellation' is set
        if ('subscription_cancellation' not in params) or (params['subscription_cancellation'] is None):
            raise ValueError("Missing the required parameter `subscription_cancellation` when calling `cancel_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/cancel'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'subscription_cancellation' in params:
            body_params = params['subscription_cancellation']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionCancellationPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_aggregating_subscription(self, request, **kwargs):
        """
        Create an aggregating subscription.
        {\"nickname\":\"Create aggregating subscription\",\"response\":\"createAggregatingSubscription.html\",\"request\":\"createAggregatingSubscription.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_aggregating_subscription(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateAggregatingSubscriptionRequest request:  (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_aggregating_subscription_with_http_info(request, **kwargs)
        else:
            (data) = self.create_aggregating_subscription_with_http_info(request, **kwargs)
            return data

    def create_aggregating_subscription_with_http_info(self, request, **kwargs):
        """
        Create an aggregating subscription.
        {\"nickname\":\"Create aggregating subscription\",\"response\":\"createAggregatingSubscription.html\",\"request\":\"createAggregatingSubscription.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_aggregating_subscription_with_http_info(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateAggregatingSubscriptionRequest request:  (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_aggregating_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `create_aggregating_subscription`")

        resource_path = '/subscriptions/aggregating'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_subscription(self, subscription, **kwargs):
        """
        Create a new subscription.
        {\"nickname\":\"Create a new subscription\",\"request\":\"createSubscriptionRequest.html\",\"response\":\"createSubscriptionResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_subscription(subscription, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Subscription subscription: The subscription object to be updated. (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_subscription_with_http_info(subscription, **kwargs)
        else:
            (data) = self.create_subscription_with_http_info(subscription, **kwargs)
            return data

    def create_subscription_with_http_info(self, subscription, **kwargs):
        """
        Create a new subscription.
        {\"nickname\":\"Create a new subscription\",\"request\":\"createSubscriptionRequest.html\",\"response\":\"createSubscriptionResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_subscription_with_http_info(subscription, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Subscription subscription: The subscription object to be updated. (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription' is set
        if ('subscription' not in params) or (params['subscription'] is None):
            raise ValueError("Missing the required parameter `subscription` when calling `create_subscription`")

        resource_path = '/subscriptions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'subscription' in params:
            body_params = params['subscription']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/xml', 'application/xml', 'application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_subscription_v2(self, request, **kwargs):
        """
        Create a subscription (V2).
        {\"nickname\":\"Create a subscription (V2)\",\"response\":\"createSubscriptionViaHelper.html\",\"request\":\"createSubscriptionViaHelper.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_subscription_v2(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateSubscriptionRequest request:  (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_subscription_v2_with_http_info(request, **kwargs)
        else:
            (data) = self.create_subscription_v2_with_http_info(request, **kwargs)
            return data

    def create_subscription_v2_with_http_info(self, request, **kwargs):
        """
        Create a subscription (V2).
        {\"nickname\":\"Create a subscription (V2)\",\"response\":\"createSubscriptionViaHelper.html\",\"request\":\"createSubscriptionViaHelper.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_subscription_v2_with_http_info(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateSubscriptionRequest request:  (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_subscription_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `create_subscription_v2`")

        resource_path = '/subscriptions/create'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_timer(self, subscription_id, request, **kwargs):
        """
        Create a timer for a subscription event.
        {\"nickname\":\"Create Timer\",\"response\":\"createSubscriptionTimer.html\",\"request\":\"createSubscriptionTimer.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_timer(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param BillingEntityBase request:  (required)
        :return: TimerAmendment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_timer_with_http_info(subscription_id, request, **kwargs)
        else:
            (data) = self.create_timer_with_http_info(subscription_id, request, **kwargs)
            return data

    def create_timer_with_http_info(self, subscription_id, request, **kwargs):
        """
        Create a timer for a subscription event.
        {\"nickname\":\"Create Timer\",\"response\":\"createSubscriptionTimer.html\",\"request\":\"createSubscriptionTimer.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_timer_with_http_info(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param BillingEntityBase request:  (required)
        :return: TimerAmendment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_timer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `create_timer`")
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `create_timer`")

        resource_path = '/subscriptions/{subscription-ID}/timer'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TimerAmendment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_metadata_for_subscription(self, subscription_id, **kwargs):
        """
        Remove any associated metadata.
        {\"nickname\":\"Clear from subscription\",\"request\" :\"deleteSubscriptionMetadataRequest.html\",\"response\":\"deleteSubscriptionMetadataResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_metadata_for_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: DynamicMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_metadata_for_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.delete_metadata_for_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def delete_metadata_for_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Remove any associated metadata.
        {\"nickname\":\"Clear from subscription\",\"request\" :\"deleteSubscriptionMetadataRequest.html\",\"response\":\"deleteSubscriptionMetadataResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_metadata_for_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: DynamicMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_metadata_for_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `delete_metadata_for_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/metadata'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DynamicMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def freeze_subscription(self, subscription_id, request, **kwargs):
        """
        Freeze the subscription.
        {\"nickname\":\"Freeze\",\"request\":\"freezeSubscriptionRequest.html\",\"response\":\"freezeSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.freeze_subscription(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param PauseRequest request: The request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.freeze_subscription_with_http_info(subscription_id, request, **kwargs)
        else:
            (data) = self.freeze_subscription_with_http_info(subscription_id, request, **kwargs)
            return data

    def freeze_subscription_with_http_info(self, subscription_id, request, **kwargs):
        """
        Freeze the subscription.
        {\"nickname\":\"Freeze\",\"request\":\"freezeSubscriptionRequest.html\",\"response\":\"freezeSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.freeze_subscription_with_http_info(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param PauseRequest request: The request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method freeze_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `freeze_subscription`")
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `freeze_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/freeze'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_all_subscriptions(self, **kwargs):
        """
        Retrieves a collection of all subscriptions. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve all subscriptions\",\"response\":\"getSubscriptionAll.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_all_subscriptions(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :param str metadata: 
        :param bool exclude_service_ended: 
        :param list[str] account_id: A list of accountIDs to filter subscriptions on
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_all_subscriptions_with_http_info(**kwargs)
        else:
            (data) = self.get_all_subscriptions_with_http_info(**kwargs)
            return data

    def get_all_subscriptions_with_http_info(self, **kwargs):
        """
        Retrieves a collection of all subscriptions. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve all subscriptions\",\"response\":\"getSubscriptionAll.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_all_subscriptions_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :param str metadata: 
        :param bool exclude_service_ended: 
        :param list[str] account_id: A list of accountIDs to filter subscriptions on
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organizations', 'offset', 'records', 'order_by', 'order', 'include_retired', 'exclude_children', 'metadata', 'exclude_service_ended', 'account_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_subscriptions" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/subscriptions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']
        if 'exclude_children' in params:
            query_params['exclude_children'] = params['exclude_children']
        if 'metadata' in params:
            query_params['metadata'] = params['metadata']
        if 'exclude_service_ended' in params:
            query_params['exclude_service_ended'] = params['exclude_service_ended']
        if 'account_id' in params:
            query_params['accountID'] = params['account_id']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_applicable_coupons_for_subscription(self, subscription_id, **kwargs):
        """
        Retrieves a collection of the coupons which can be applied to this subscription.
        { \"nickname\" : \"Retrieve applicable coupons\",\"response\" : \"getApplicableCoupons.html\" }

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_applicable_coupons_for_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: CouponPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_applicable_coupons_for_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_applicable_coupons_for_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_applicable_coupons_for_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Retrieves a collection of the coupons which can be applied to this subscription.
        { \"nickname\" : \"Retrieve applicable coupons\",\"response\" : \"getApplicableCoupons.html\" }

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_applicable_coupons_for_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: CouponPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applicable_coupons_for_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_applicable_coupons_for_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/applicable-coupons'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='CouponPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_available_credit_subscription(self, subscription_id, **kwargs):
        """
        Returns all available credit-notes for the specified subscription. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Get available credit\",\"response\":\"getAvailableCreditSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_available_credit_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: CreditNotePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_available_credit_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_available_credit_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_available_credit_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Returns all available credit-notes for the specified subscription. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Get available credit\",\"response\":\"getAvailableCreditSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_available_credit_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: CreditNotePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_available_credit_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_available_credit_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/credit'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='CreditNotePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_charges_on_subscription(self, subscription_id, **kwargs):
        """
        Returns all charges for the specified subscription. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Get charges\",\"response\":\"getChargesSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_charges_on_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param str state: Ihe direction of any ordering, either ASC or DESC.
        :param str type: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: SubscriptionChargePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_charges_on_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_charges_on_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_charges_on_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Returns all charges for the specified subscription. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Get charges\",\"response\":\"getChargesSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_charges_on_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param str state: Ihe direction of any ordering, either ASC or DESC.
        :param str type: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: SubscriptionChargePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'state', 'type', 'include_retired']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_charges_on_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_charges_on_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/charges'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'state' in params:
            query_params['state'] = params['state']
        if 'type' in params:
            query_params['type'] = params['type']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionChargePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_children_of_subscription(self, subscription_id, **kwargs):
        """
        Return all entities whose invoices will be aggregated by the specified subscription By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Get Aggregated Entities\",\"response\":\"getAggregatedEntities.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_children_of_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_children_of_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_children_of_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_children_of_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Return all entities whose invoices will be aggregated by the specified subscription By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Get Aggregated Entities\",\"response\":\"getAggregatedEntities.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_children_of_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_children_of_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_children_of_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/children'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_coupons_on_subscription(self, subscription_id, **kwargs):
        """
        Retrieves a collection of the coupons and the unique codes currently applied to the subscription.
        {\"nickname\":\"Retrieve coupons\",\"response\":\"getCoupons.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_coupons_on_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: CouponPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_coupons_on_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_coupons_on_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_coupons_on_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Retrieves a collection of the coupons and the unique codes currently applied to the subscription.
        {\"nickname\":\"Retrieve coupons\",\"response\":\"getCoupons.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_coupons_on_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: CouponPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons_on_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_coupons_on_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/coupons'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='CouponPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_invoices_for_subscription_by_state(self, subscription_id, state, **kwargs):
        """
        Retrieves a collection of invoice objects of the specified state for the given subscription. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve invoices by state for subscription\",\"response\":\"getInvoicesForSubscriptionByState.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_invoices_for_subscription_by_state(subscription_id, state, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: The unique id of the subscription. (required)
        :param str state: The state of the invoices to retrieve. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: InvoicePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_invoices_for_subscription_by_state_with_http_info(subscription_id, state, **kwargs)
        else:
            (data) = self.get_invoices_for_subscription_by_state_with_http_info(subscription_id, state, **kwargs)
            return data

    def get_invoices_for_subscription_by_state_with_http_info(self, subscription_id, state, **kwargs):
        """
        Retrieves a collection of invoice objects of the specified state for the given subscription. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve invoices by state for subscription\",\"response\":\"getInvoicesForSubscriptionByState.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_invoices_for_subscription_by_state_with_http_info(subscription_id, state, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: The unique id of the subscription. (required)
        :param str state: The state of the invoices to retrieve. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: InvoicePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'state', 'organizations', 'offset', 'records', 'order_by', 'order']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoices_for_subscription_by_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_invoices_for_subscription_by_state`")
        # verify the required parameter 'state' is set
        if ('state' not in params) or (params['state'] is None):
            raise ValueError("Missing the required parameter `state` when calling `get_invoices_for_subscription_by_state`")

        resource_path = '/subscriptions/{subscriptionID}/invoices/{state}'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscriptionID'] = params['subscription_id']
        if 'state' in params:
            path_params['state'] = params['state']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InvoicePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_metadata_for_subscription(self, subscription_id, **kwargs):
        """
        Retrieve any associated metadata.
        {\"nickname\":\"Retrieve on subscription\",\"request\":\"getSubscriptionMetadataRequest.html\",\"response\":\"getSubscriptionMetadataResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_metadata_for_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: DynamicMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_metadata_for_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_metadata_for_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_metadata_for_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Retrieve any associated metadata.
        {\"nickname\":\"Retrieve on subscription\",\"request\":\"getSubscriptionMetadataRequest.html\",\"response\":\"getSubscriptionMetadataResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_metadata_for_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: DynamicMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metadata_for_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_metadata_for_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/metadata'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DynamicMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_parent_subscription(self, subscription_id, **kwargs):
        """
        Return the parent of the given subscription.
        {\"nickname\":\"Get parent\",\"response\":\"getParentSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_parent_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_parent_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_parent_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_parent_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Return the parent of the given subscription.
        {\"nickname\":\"Get parent\",\"response\":\"getParentSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_parent_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parent_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_parent_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/parent'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_pricing_component_values_of_subscription(self, subscription_id, **kwargs):
        """
        Gets the subscription's current pricing-component values.
        {\"nickname\":\"Get values\",\"response\":\"getPricingComponentValues.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pricing_component_values_of_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :return: PricingComponentValuePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pricing_component_values_of_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_pricing_component_values_of_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_pricing_component_values_of_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Gets the subscription's current pricing-component values.
        {\"nickname\":\"Get values\",\"response\":\"getPricingComponentValues.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pricing_component_values_of_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :return: PricingComponentValuePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pricing_component_values_of_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_pricing_component_values_of_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/values'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PricingComponentValuePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscription_by_account_id(self, account_id, **kwargs):
        """
        Retrieves a collection of subscriptions, specified by the account-ID parameter. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by account\",\"response\":\"getSubscriptionByAccount.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_account_id(account_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str account_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscription_by_account_id_with_http_info(account_id, **kwargs)
        else:
            (data) = self.get_subscription_by_account_id_with_http_info(account_id, **kwargs)
            return data

    def get_subscription_by_account_id_with_http_info(self, account_id, **kwargs):
        """
        Retrieves a collection of subscriptions, specified by the account-ID parameter. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by account\",\"response\":\"getSubscriptionByAccount.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_account_id_with_http_info(account_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str account_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired', 'exclude_children']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_by_account_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params) or (params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_subscription_by_account_id`")

        resource_path = '/subscriptions/account/{account-ID}'.replace('{format}', 'json')
        path_params = {}
        if 'account_id' in params:
            path_params['account-ID'] = params['account_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']
        if 'exclude_children' in params:
            query_params['exclude_children'] = params['exclude_children']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscription_by_id(self, subscription_id, **kwargs):
        """
        Retrieves a single subscription, specified by the ID parameter.
        {\"nickname\":\"Retrieve an existing subscription\",\"response\":\"getSubscriptionByID.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_id(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscription_by_id_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_subscription_by_id_with_http_info(subscription_id, **kwargs)
            return data

    def get_subscription_by_id_with_http_info(self, subscription_id, **kwargs):
        """
        Retrieves a single subscription, specified by the ID parameter.
        {\"nickname\":\"Retrieve an existing subscription\",\"response\":\"getSubscriptionByID.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_id_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations', 'include_retired']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_subscription_by_id`")

        resource_path = '/subscriptions/{subscription-ID}'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscription_by_product_id(self, product_id, **kwargs):
        """
        Retrieves a collection of subscriptions, specified by the product-ID parameter. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by product\",\"response\":\"getSubscriptionByProduct.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_product_id(product_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str product_id: ID of the product (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscription_by_product_id_with_http_info(product_id, **kwargs)
        else:
            (data) = self.get_subscription_by_product_id_with_http_info(product_id, **kwargs)
            return data

    def get_subscription_by_product_id_with_http_info(self, product_id, **kwargs):
        """
        Retrieves a collection of subscriptions, specified by the product-ID parameter. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by product\",\"response\":\"getSubscriptionByProduct.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_product_id_with_http_info(product_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str product_id: ID of the product (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['product_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired', 'exclude_children']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_by_product_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'product_id' is set
        if ('product_id' not in params) or (params['product_id'] is None):
            raise ValueError("Missing the required parameter `product_id` when calling `get_subscription_by_product_id`")

        resource_path = '/subscriptions/product/{product-ID}'.replace('{format}', 'json')
        path_params = {}
        if 'product_id' in params:
            path_params['product-ID'] = params['product_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']
        if 'exclude_children' in params:
            query_params['exclude_children'] = params['exclude_children']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscription_by_product_rate_plan_id(self, product_rate_plan_id, **kwargs):
        """
        Retrieves a collection of subscriptions, specified by the product-rate-plan-ID parameter. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by rate-plan\",\"response\":\"getSubscriptionByProductRatePlan.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_product_rate_plan_id(product_rate_plan_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str product_rate_plan_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscription_by_product_rate_plan_id_with_http_info(product_rate_plan_id, **kwargs)
        else:
            (data) = self.get_subscription_by_product_rate_plan_id_with_http_info(product_rate_plan_id, **kwargs)
            return data

    def get_subscription_by_product_rate_plan_id_with_http_info(self, product_rate_plan_id, **kwargs):
        """
        Retrieves a collection of subscriptions, specified by the product-rate-plan-ID parameter. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by rate-plan\",\"response\":\"getSubscriptionByProductRatePlan.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_product_rate_plan_id_with_http_info(product_rate_plan_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str product_rate_plan_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['product_rate_plan_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired', 'exclude_children']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_by_product_rate_plan_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'product_rate_plan_id' is set
        if ('product_rate_plan_id' not in params) or (params['product_rate_plan_id'] is None):
            raise ValueError("Missing the required parameter `product_rate_plan_id` when calling `get_subscription_by_product_rate_plan_id`")

        resource_path = '/subscriptions/product-rate-plan/{product-rate-plan-ID}'.replace('{format}', 'json')
        path_params = {}
        if 'product_rate_plan_id' in params:
            path_params['product-rate-plan-ID'] = params['product_rate_plan_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']
        if 'exclude_children' in params:
            query_params['exclude_children'] = params['exclude_children']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscription_by_state(self, state, **kwargs):
        """
        Retrieves a collection of subscriptions, specified by the state parameter. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by state\",\"response\":\"getSubscriptionByState.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_state(state, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str state: The current state of the subscription, either Provisioned, AwaitingPayment, Paid or Cancelled (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscription_by_state_with_http_info(state, **kwargs)
        else:
            (data) = self.get_subscription_by_state_with_http_info(state, **kwargs)
            return data

    def get_subscription_by_state_with_http_info(self, state, **kwargs):
        """
        Retrieves a collection of subscriptions, specified by the state parameter. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by state\",\"response\":\"getSubscriptionByState.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_state_with_http_info(state, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str state: The current state of the subscription, either Provisioned, AwaitingPayment, Paid or Cancelled (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired subscriptions should be returned.
        :param bool exclude_children: Should child subscriptiosn be excluded.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['state', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired', 'exclude_children']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_by_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'state' is set
        if ('state' not in params) or (params['state'] is None):
            raise ValueError("Missing the required parameter `state` when calling `get_subscription_by_state`")

        resource_path = '/subscriptions/state/{state}'.replace('{format}', 'json')
        path_params = {}
        if 'state' in params:
            path_params['state'] = params['state']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']
        if 'exclude_children' in params:
            query_params['exclude_children'] = params['exclude_children']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscription_by_version_id(self, version_id, **kwargs):
        """
        Retrieves a single subscription, specified by the version-ID parameter.
        {\"nickname\":\"Retrieve by version\",\"response\":\"getSubscriptionByVersionID.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_version_id(version_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str version_id: The version-ID of the subscription. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscription_by_version_id_with_http_info(version_id, **kwargs)
        else:
            (data) = self.get_subscription_by_version_id_with_http_info(version_id, **kwargs)
            return data

    def get_subscription_by_version_id_with_http_info(self, version_id, **kwargs):
        """
        Retrieves a single subscription, specified by the version-ID parameter.
        {\"nickname\":\"Retrieve by version\",\"response\":\"getSubscriptionByVersionID.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscription_by_version_id_with_http_info(version_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str version_id: The version-ID of the subscription. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version_id', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_by_version_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'version_id' is set
        if ('version_id' not in params) or (params['version_id'] is None):
            raise ValueError("Missing the required parameter `version_id` when calling `get_subscription_by_version_id`")

        resource_path = '/subscriptions/version/{version-ID}'.replace('{format}', 'json')
        path_params = {}
        if 'version_id' in params:
            path_params['version-ID'] = params['version_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscriptions_by_initial_period_start(self, lower_threshold, upper_threshold, **kwargs):
        """
        Retrieves a collection of subscription objects with period-end times within the period specified by the lower-threshold and upper-threshold parameters. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by initial period-start\",\"response\":\"getSubscriptionByInitialPeriodStart.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscriptions_by_initial_period_start(lower_threshold, upper_threshold, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str lower_threshold: The UTC DateTime specifying the start of the result period. (required)
        :param str upper_threshold: The UTC DateTime specifying the end of the result period. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscriptions_by_initial_period_start_with_http_info(lower_threshold, upper_threshold, **kwargs)
        else:
            (data) = self.get_subscriptions_by_initial_period_start_with_http_info(lower_threshold, upper_threshold, **kwargs)
            return data

    def get_subscriptions_by_initial_period_start_with_http_info(self, lower_threshold, upper_threshold, **kwargs):
        """
        Retrieves a collection of subscription objects with period-end times within the period specified by the lower-threshold and upper-threshold parameters. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by initial period-start\",\"response\":\"getSubscriptionByInitialPeriodStart.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscriptions_by_initial_period_start_with_http_info(lower_threshold, upper_threshold, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str lower_threshold: The UTC DateTime specifying the start of the result period. (required)
        :param str upper_threshold: The UTC DateTime specifying the end of the result period. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lower_threshold', 'upper_threshold', 'organizations', 'offset', 'records', 'order_by', 'order']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscriptions_by_initial_period_start" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lower_threshold' is set
        if ('lower_threshold' not in params) or (params['lower_threshold'] is None):
            raise ValueError("Missing the required parameter `lower_threshold` when calling `get_subscriptions_by_initial_period_start`")
        # verify the required parameter 'upper_threshold' is set
        if ('upper_threshold' not in params) or (params['upper_threshold'] is None):
            raise ValueError("Missing the required parameter `upper_threshold` when calling `get_subscriptions_by_initial_period_start`")

        resource_path = '/subscriptions/initial-period-start/{lower-threshold}/{upper-threshold}'.replace('{format}', 'json')
        path_params = {}
        if 'lower_threshold' in params:
            path_params['lower-threshold'] = params['lower_threshold']
        if 'upper_threshold' in params:
            path_params['upper-threshold'] = params['upper_threshold']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscriptions_by_period_end(self, lower_threshold, upper_threshold, **kwargs):
        """
        Retrieves a collection of subscription objects with period-end times within the period specified by the lower-threshold and upper-threshold parameters. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by period-end\",\"response\":\"getSubscriptionByPeriodEnd.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscriptions_by_period_end(lower_threshold, upper_threshold, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str lower_threshold: The UTC DateTime specifying the start of the result period. (required)
        :param str upper_threshold: The UTC DateTime specifying the end of the result period. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscriptions_by_period_end_with_http_info(lower_threshold, upper_threshold, **kwargs)
        else:
            (data) = self.get_subscriptions_by_period_end_with_http_info(lower_threshold, upper_threshold, **kwargs)
            return data

    def get_subscriptions_by_period_end_with_http_info(self, lower_threshold, upper_threshold, **kwargs):
        """
        Retrieves a collection of subscription objects with period-end times within the period specified by the lower-threshold and upper-threshold parameters. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by period-end\",\"response\":\"getSubscriptionByPeriodEnd.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscriptions_by_period_end_with_http_info(lower_threshold, upper_threshold, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str lower_threshold: The UTC DateTime specifying the start of the result period. (required)
        :param str upper_threshold: The UTC DateTime specifying the end of the result period. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lower_threshold', 'upper_threshold', 'organizations', 'offset', 'records', 'order_by', 'order']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscriptions_by_period_end" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lower_threshold' is set
        if ('lower_threshold' not in params) or (params['lower_threshold'] is None):
            raise ValueError("Missing the required parameter `lower_threshold` when calling `get_subscriptions_by_period_end`")
        # verify the required parameter 'upper_threshold' is set
        if ('upper_threshold' not in params) or (params['upper_threshold'] is None):
            raise ValueError("Missing the required parameter `upper_threshold` when calling `get_subscriptions_by_period_end`")

        resource_path = '/subscriptions/period-end/{lower-threshold}/{upper-threshold}'.replace('{format}', 'json')
        path_params = {}
        if 'lower_threshold' in params:
            path_params['lower-threshold'] = params['lower_threshold']
        if 'upper_threshold' in params:
            path_params['upper-threshold'] = params['upper_threshold']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscriptions_by_period_start(self, lower_threshold, upper_threshold, **kwargs):
        """
        Retrieves a collection of subscription objects with period-start times within the period specified by the lower-threshold and upper-threshold parameters. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by period-start\",\"response\":\"getSubscriptionByPeriodStart.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscriptions_by_period_start(lower_threshold, upper_threshold, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str lower_threshold: The UTC DateTime specifying the start of the result period. (required)
        :param str upper_threshold: The UTC DateTime specifying the end of the result period. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscriptions_by_period_start_with_http_info(lower_threshold, upper_threshold, **kwargs)
        else:
            (data) = self.get_subscriptions_by_period_start_with_http_info(lower_threshold, upper_threshold, **kwargs)
            return data

    def get_subscriptions_by_period_start_with_http_info(self, lower_threshold, upper_threshold, **kwargs):
        """
        Retrieves a collection of subscription objects with period-start times within the period specified by the lower-threshold and upper-threshold parameters. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by period-start\",\"response\":\"getSubscriptionByPeriodStart.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscriptions_by_period_start_with_http_info(lower_threshold, upper_threshold, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str lower_threshold: The UTC DateTime specifying the start of the result period. (required)
        :param str upper_threshold: The UTC DateTime specifying the end of the result period. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lower_threshold', 'upper_threshold', 'organizations', 'offset', 'records', 'order_by', 'order']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscriptions_by_period_start" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lower_threshold' is set
        if ('lower_threshold' not in params) or (params['lower_threshold'] is None):
            raise ValueError("Missing the required parameter `lower_threshold` when calling `get_subscriptions_by_period_start`")
        # verify the required parameter 'upper_threshold' is set
        if ('upper_threshold' not in params) or (params['upper_threshold'] is None):
            raise ValueError("Missing the required parameter `upper_threshold` when calling `get_subscriptions_by_period_start`")

        resource_path = '/subscriptions/period-start/{lower-threshold}/{upper-threshold}'.replace('{format}', 'json')
        path_params = {}
        if 'lower_threshold' in params:
            path_params['lower-threshold'] = params['lower_threshold']
        if 'upper_threshold' in params:
            path_params['upper-threshold'] = params['upper_threshold']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_subscriptions_by_successful_periods(self, lower_threshold, upper_threshold, **kwargs):
        """
        Retrieves a collection of subscription objects whose successful periods count falls within the range specified by the lower-threshold and upper-threshold parameters. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by successful period\",\"response\":\"getSubscriptionBySuccessfulPeriods.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscriptions_by_successful_periods(lower_threshold, upper_threshold, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int lower_threshold: The lower threshold of the range (required)
        :param int upper_threshold: The upper threshold of the range. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subscriptions_by_successful_periods_with_http_info(lower_threshold, upper_threshold, **kwargs)
        else:
            (data) = self.get_subscriptions_by_successful_periods_with_http_info(lower_threshold, upper_threshold, **kwargs)
            return data

    def get_subscriptions_by_successful_periods_with_http_info(self, lower_threshold, upper_threshold, **kwargs):
        """
        Retrieves a collection of subscription objects whose successful periods count falls within the range specified by the lower-threshold and upper-threshold parameters. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Retrieve by successful period\",\"response\":\"getSubscriptionBySuccessfulPeriods.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subscriptions_by_successful_periods_with_http_info(lower_threshold, upper_threshold, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int lower_threshold: The lower threshold of the range (required)
        :param int upper_threshold: The upper threshold of the range. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first taxation-link to return.
        :param int records: The maximum number of taxation-links to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lower_threshold', 'upper_threshold', 'organizations', 'offset', 'records', 'order_by', 'order']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscriptions_by_successful_periods" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lower_threshold' is set
        if ('lower_threshold' not in params) or (params['lower_threshold'] is None):
            raise ValueError("Missing the required parameter `lower_threshold` when calling `get_subscriptions_by_successful_periods`")
        # verify the required parameter 'upper_threshold' is set
        if ('upper_threshold' not in params) or (params['upper_threshold'] is None):
            raise ValueError("Missing the required parameter `upper_threshold` when calling `get_subscriptions_by_successful_periods`")

        resource_path = '/subscriptions/successful-periods/{lower-threshold}/{upper-threshold}'.replace('{format}', 'json')
        path_params = {}
        if 'lower_threshold' in params:
            path_params['lower-threshold'] = params['lower_threshold']
        if 'upper_threshold' in params:
            path_params['upper-threshold'] = params['upper_threshold']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_swagger_subscription(self, query_string, **kwargs):
        """
        
        { \"nickname\" : \"\",\"response\" : \"\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_swagger_subscription(query_string, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query_string: The query string used to search. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The starting index of the search results.
        :param int records: The number of search results to return.
        :param str format: The response format, either JSON or XML.
        :param bool wildcard: Toggle if we search for full words or whether a wildcard is used.
        :param bool entity: Is an entity returned with the search results.
        :return: SwaggerTypeListSubs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_swagger_subscription_with_http_info(query_string, **kwargs)
        else:
            (data) = self.get_swagger_subscription_with_http_info(query_string, **kwargs)
            return data

    def get_swagger_subscription_with_http_info(self, query_string, **kwargs):
        """
        
        { \"nickname\" : \"\",\"response\" : \"\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_swagger_subscription_with_http_info(query_string, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query_string: The query string used to search. (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The starting index of the search results.
        :param int records: The number of search results to return.
        :param str format: The response format, either JSON or XML.
        :param bool wildcard: Toggle if we search for full words or whether a wildcard is used.
        :param bool entity: Is an entity returned with the search results.
        :return: SwaggerTypeListSubs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_string', 'organizations', 'offset', 'records', 'format', 'wildcard', 'entity']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_swagger_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query_string' is set
        if ('query_string' not in params) or (params['query_string'] is None):
            raise ValueError("Missing the required parameter `query_string` when calling `get_swagger_subscription`")

        resource_path = '/subscriptions/swagger-end-point/{query-string}'.replace('{format}', 'json')
        path_params = {}
        if 'query_string' in params:
            path_params['query-string'] = params['query_string']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'format' in params:
            query_params['format'] = params['format']
        if 'wildcard' in params:
            query_params['wildcard'] = params['wildcard']
        if 'entity' in params:
            query_params['entity'] = params['entity']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SwaggerTypeListSubs',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_timers_for_subscription(self, subscription_id, **kwargs):
        """
        Retrieves a collection timer amendments for the specified subscription.. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Get Timers\",\"response\":\"getTimersforSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_timers_for_subscription(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired timers should be returned.
        :param str state: The state of the timer amendment
        :param str event: The type of timer event
        :return: TimerAmendment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_timers_for_subscription_with_http_info(subscription_id, **kwargs)
        else:
            (data) = self.get_timers_for_subscription_with_http_info(subscription_id, **kwargs)
            return data

    def get_timers_for_subscription_with_http_info(self, subscription_id, **kwargs):
        """
        Retrieves a collection timer amendments for the specified subscription.. By default 10 values are returned. Records are returned in natural order.
        {\"nickname\":\"Get Timers\",\"response\":\"getTimersforSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_timers_for_subscription_with_http_info(subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :param int offset: The offset from the first subscription to return.
        :param int records: The maximum number of subscriptions to return.
        :param str order_by: Specify a field used to order the result set.
        :param str order: Ihe direction of any ordering, either ASC or DESC.
        :param bool include_retired: Whether retired timers should be returned.
        :param str state: The state of the timer amendment
        :param str event: The type of timer event
        :return: TimerAmendment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'organizations', 'offset', 'records', 'order_by', 'order', 'include_retired', 'state', 'event']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_timers_for_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `get_timers_for_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/timer'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']
        if 'offset' in params:
            query_params['offset'] = params['offset']
        if 'records' in params:
            query_params['records'] = params['records']
        if 'order_by' in params:
            query_params['order_by'] = params['order_by']
        if 'order' in params:
            query_params['order'] = params['order']
        if 'include_retired' in params:
            query_params['include_retired'] = params['include_retired']
        if 'state' in params:
            query_params['state'] = params['state']
        if 'event' in params:
            query_params['event'] = params['event']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='TimerAmendment',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def import_subscription(self, request, **kwargs):
        """
        Import a subscription.
        {\"nickname\":\"Import\",\"request\":\"importSubscriptionRequest.html\",\"response\":\"importSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.import_subscription(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param BillingEntityBase request: The request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.import_subscription_with_http_info(request, **kwargs)
        else:
            (data) = self.import_subscription_with_http_info(request, **kwargs)
            return data

    def import_subscription_with_http_info(self, request, **kwargs):
        """
        Import a subscription.
        {\"nickname\":\"Import\",\"request\":\"importSubscriptionRequest.html\",\"response\":\"importSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.import_subscription_with_http_info(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param BillingEntityBase request: The request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `import_subscription`")

        resource_path = '/subscriptions/import'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def invoice_charges_on_subscription(self, subscription_id, charge, **kwargs):
        """
        Invoice any outstanding charges for the subscription.
        {\"nickname\":\"Invoice Charges\",\"request\":\"invoiceChargesRequest.html\",\"response\":\"invoiceCharges.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invoice_charges_on_subscription(subscription_id, charge, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param InvoiceChargeRequest charge: The charge request (required)
        :return: InvoicePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.invoice_charges_on_subscription_with_http_info(subscription_id, charge, **kwargs)
        else:
            (data) = self.invoice_charges_on_subscription_with_http_info(subscription_id, charge, **kwargs)
            return data

    def invoice_charges_on_subscription_with_http_info(self, subscription_id, charge, **kwargs):
        """
        Invoice any outstanding charges for the subscription.
        {\"nickname\":\"Invoice Charges\",\"request\":\"invoiceChargesRequest.html\",\"response\":\"invoiceCharges.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.invoice_charges_on_subscription_with_http_info(subscription_id, charge, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param InvoiceChargeRequest charge: The charge request (required)
        :return: InvoicePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'charge']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invoice_charges_on_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `invoice_charges_on_subscription`")
        # verify the required parameter 'charge' is set
        if ('charge' not in params) or (params['charge'] is None):
            raise ValueError("Missing the required parameter `charge` when calling `invoice_charges_on_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/invoice-charges'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'charge' in params:
            body_params = params['charge']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='InvoicePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def migrate_subscription(self, subscription_id, request, **kwargs):
        """
        Migrate the subscription to a new plan.
        {\"nickname\":\"Migrate\",\"request\":\"migrateSubscriptionRequest.html\", \"response\":\"migrateSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.migrate_subscription(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param MigrationRequest request: The migration request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.migrate_subscription_with_http_info(subscription_id, request, **kwargs)
        else:
            (data) = self.migrate_subscription_with_http_info(subscription_id, request, **kwargs)
            return data

    def migrate_subscription_with_http_info(self, subscription_id, request, **kwargs):
        """
        Migrate the subscription to a new plan.
        {\"nickname\":\"Migrate\",\"request\":\"migrateSubscriptionRequest.html\", \"response\":\"migrateSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.migrate_subscription_with_http_info(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param MigrationRequest request: The migration request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method migrate_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `migrate_subscription`")
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `migrate_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/migrate'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def remove_coupon_from_subscription(self, subscription_id, coupon_code, **kwargs):
        """
        Removes the coupon from the subscription.
        {\"nickname\":\"Remove coupon\",\"response\":\"removeCouponResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_coupon_from_subscription(subscription_id, coupon_code, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str coupon_code:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: CouponPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_coupon_from_subscription_with_http_info(subscription_id, coupon_code, **kwargs)
        else:
            (data) = self.remove_coupon_from_subscription_with_http_info(subscription_id, coupon_code, **kwargs)
            return data

    def remove_coupon_from_subscription_with_http_info(self, subscription_id, coupon_code, **kwargs):
        """
        Removes the coupon from the subscription.
        {\"nickname\":\"Remove coupon\",\"response\":\"removeCouponResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_coupon_from_subscription_with_http_info(subscription_id, coupon_code, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str coupon_code:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: CouponPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'coupon_code', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_coupon_from_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `remove_coupon_from_subscription`")
        # verify the required parameter 'coupon_code' is set
        if ('coupon_code' not in params) or (params['coupon_code'] is None):
            raise ValueError("Missing the required parameter `coupon_code` when calling `remove_coupon_from_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/coupons/{coupon-code}'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']
        if 'coupon_code' in params:
            path_params['coupon-code'] = params['coupon_code']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='CouponPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def remove_credit_from_subscription(self, subscription_id, value, **kwargs):
        """
        Decrease the amount of credit available to the specified subscription.
        {\"nickname\":\"Remove Credit\",\"response\":\"removeCreditForSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_credit_from_subscription(subscription_id, value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str value: <p>Either a credit note ID or a currency value.</p><p>If a credit note ID is provided any remaining credit will be removed.</p><p>If a decimal is provided this value will be removed from any credit available to the subscription. For example if the subscription is in USD setting the value as 10 will reduce credit by $10 (USD), setting 9.86  would reduce the credit by $9.86 (USD). The value will be reduced from any credit available.</p> (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: CreditNotePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_credit_from_subscription_with_http_info(subscription_id, value, **kwargs)
        else:
            (data) = self.remove_credit_from_subscription_with_http_info(subscription_id, value, **kwargs)
            return data

    def remove_credit_from_subscription_with_http_info(self, subscription_id, value, **kwargs):
        """
        Decrease the amount of credit available to the specified subscription.
        {\"nickname\":\"Remove Credit\",\"response\":\"removeCreditForSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_credit_from_subscription_with_http_info(subscription_id, value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str value: <p>Either a credit note ID or a currency value.</p><p>If a credit note ID is provided any remaining credit will be removed.</p><p>If a decimal is provided this value will be removed from any credit available to the subscription. For example if the subscription is in USD setting the value as 10 will reduce credit by $10 (USD), setting 9.86  would reduce the credit by $9.86 (USD). The value will be reduced from any credit available.</p> (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: CreditNotePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'value', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_credit_from_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `remove_credit_from_subscription`")
        # verify the required parameter 'value' is set
        if ('value' not in params) or (params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `remove_credit_from_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/credit/{value}'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']
        if 'value' in params:
            path_params['value'] = params['value']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='CreditNotePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def remove_payment_method_from_subscription(self, subscription_id, payment_method_id, **kwargs):
        """
        Removes the specified payment method for the given subscription.
        {\"nickname\":\"Remove payment-method\",\"response\":\"removePaymentMethod.html\",\"request\":\"removePaymentMethod.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_payment_method_from_subscription(subscription_id, payment_method_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str payment_method_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: PaymentMethodPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_payment_method_from_subscription_with_http_info(subscription_id, payment_method_id, **kwargs)
        else:
            (data) = self.remove_payment_method_from_subscription_with_http_info(subscription_id, payment_method_id, **kwargs)
            return data

    def remove_payment_method_from_subscription_with_http_info(self, subscription_id, payment_method_id, **kwargs):
        """
        Removes the specified payment method for the given subscription.
        {\"nickname\":\"Remove payment-method\",\"response\":\"removePaymentMethod.html\",\"request\":\"removePaymentMethod.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_payment_method_from_subscription_with_http_info(subscription_id, payment_method_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str payment_method_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: PaymentMethodPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'payment_method_id', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_payment_method_from_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `remove_payment_method_from_subscription`")
        # verify the required parameter 'payment_method_id' is set
        if ('payment_method_id' not in params) or (params['payment_method_id'] is None):
            raise ValueError("Missing the required parameter `payment_method_id` when calling `remove_payment_method_from_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/payment-methods/{payment-method-ID}'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']
        if 'payment_method_id' in params:
            path_params['payment-method-ID'] = params['payment_method_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PaymentMethodPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def remove_pricing_component_value_change_from_subscription(self, subscription_id, pricing_component, **kwargs):
        """
        Discards from the subscription any scheduled changes in the value of the specified pricing-component.
        {\"nickname\":\"Discard value changes\",\"response\":\"removePricingComponentValueChange.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_pricing_component_value_change_from_subscription(subscription_id, pricing_component, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str pricing_component:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: PaymentMethodPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_pricing_component_value_change_from_subscription_with_http_info(subscription_id, pricing_component, **kwargs)
        else:
            (data) = self.remove_pricing_component_value_change_from_subscription_with_http_info(subscription_id, pricing_component, **kwargs)
            return data

    def remove_pricing_component_value_change_from_subscription_with_http_info(self, subscription_id, pricing_component, **kwargs):
        """
        Discards from the subscription any scheduled changes in the value of the specified pricing-component.
        {\"nickname\":\"Discard value changes\",\"response\":\"removePricingComponentValueChange.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_pricing_component_value_change_from_subscription_with_http_info(subscription_id, pricing_component, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str pricing_component:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: PaymentMethodPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'pricing_component', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_pricing_component_value_change_from_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `remove_pricing_component_value_change_from_subscription`")
        # verify the required parameter 'pricing_component' is set
        if ('pricing_component' not in params) or (params['pricing_component'] is None):
            raise ValueError("Missing the required parameter `pricing_component` when calling `remove_pricing_component_value_change_from_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/values/{pricing-component}'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']
        if 'pricing_component' in params:
            path_params['pricing-component'] = params['pricing_component']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['text/plain', 'application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PaymentMethodPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def resume_subscription(self, subscription_id, request, **kwargs):
        """
        Resume the frozen subscription.
        {\"nickname\":\"Resume\",\"request\":\"resumeSubscriptionRequest.html\",\"response\":\"resumeSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.resume_subscription(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param ResumeRequest request: The request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.resume_subscription_with_http_info(subscription_id, request, **kwargs)
        else:
            (data) = self.resume_subscription_with_http_info(subscription_id, request, **kwargs)
            return data

    def resume_subscription_with_http_info(self, subscription_id, request, **kwargs):
        """
        Resume the frozen subscription.
        {\"nickname\":\"Resume\",\"request\":\"resumeSubscriptionRequest.html\",\"response\":\"resumeSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.resume_subscription_with_http_info(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param ResumeRequest request: The request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `resume_subscription`")
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `resume_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/resume'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def revive_subscription(self, subscription_id, request, **kwargs):
        """
        Revives a cancelled subscription and returns it to its previous state
        {\"nickname\":\"Revive subscription\",\"request\":\"reviveSubscriptionRequest.html\", \"response\":\"reviveSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.revive_subscription(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param ReviveSubscriptionRequest request: The revive request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.revive_subscription_with_http_info(subscription_id, request, **kwargs)
        else:
            (data) = self.revive_subscription_with_http_info(subscription_id, request, **kwargs)
            return data

    def revive_subscription_with_http_info(self, subscription_id, request, **kwargs):
        """
        Revives a cancelled subscription and returns it to its previous state
        {\"nickname\":\"Revive subscription\",\"request\":\"reviveSubscriptionRequest.html\", \"response\":\"reviveSubscription.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.revive_subscription_with_http_info(subscription_id, request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param ReviveSubscriptionRequest request: The revive request (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revive_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `revive_subscription`")
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `revive_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/revive'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def set_metadata_for_subscription(self, metadata, subscription_id, **kwargs):
        """
        Remove any existing metadata keys and create the provided data.
        {\"nickname\":\"Set on subscription\",\"request\":\"setSubscriptionMetadataRequest.html\",\"response\":\"setSubscriptionMetadataResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_metadata_for_subscription(metadata, subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DynamicMetadata metadata:  (required)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: DynamicMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_metadata_for_subscription_with_http_info(metadata, subscription_id, **kwargs)
        else:
            (data) = self.set_metadata_for_subscription_with_http_info(metadata, subscription_id, **kwargs)
            return data

    def set_metadata_for_subscription_with_http_info(self, metadata, subscription_id, **kwargs):
        """
        Remove any existing metadata keys and create the provided data.
        {\"nickname\":\"Set on subscription\",\"request\":\"setSubscriptionMetadataRequest.html\",\"response\":\"setSubscriptionMetadataResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_metadata_for_subscription_with_http_info(metadata, subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DynamicMetadata metadata:  (required)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: DynamicMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['metadata', 'subscription_id', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_metadata_for_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'metadata' is set
        if ('metadata' not in params) or (params['metadata'] is None):
            raise ValueError("Missing the required parameter `metadata` when calling `set_metadata_for_subscription`")
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `set_metadata_for_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/metadata'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'metadata' in params:
            body_params = params['metadata']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DynamicMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def set_pricing_component_value_on_subscription(self, subscription_id, pricing_component_value, **kwargs):
        """
        Sets upon this subscription a new value for the specified pricing-component without performing an upgrade.
        {\"nickname\":\"Set values\",\"request\":\"setPricingComponentValuesRequest.html\",\"response\":\"setPricingComponentValues.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_pricing_component_value_on_subscription(subscription_id, pricing_component_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param PricingComponentValue pricing_component_value: The pricing-component-value request (required)
        :return: PricingComponentValuePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_pricing_component_value_on_subscription_with_http_info(subscription_id, pricing_component_value, **kwargs)
        else:
            (data) = self.set_pricing_component_value_on_subscription_with_http_info(subscription_id, pricing_component_value, **kwargs)
            return data

    def set_pricing_component_value_on_subscription_with_http_info(self, subscription_id, pricing_component_value, **kwargs):
        """
        Sets upon this subscription a new value for the specified pricing-component without performing an upgrade.
        {\"nickname\":\"Set values\",\"request\":\"setPricingComponentValuesRequest.html\",\"response\":\"setPricingComponentValues.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_pricing_component_value_on_subscription_with_http_info(subscription_id, pricing_component_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id: ID of the subscription. (required)
        :param PricingComponentValue pricing_component_value: The pricing-component-value request (required)
        :return: PricingComponentValuePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'pricing_component_value']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_pricing_component_value_on_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `set_pricing_component_value_on_subscription`")
        # verify the required parameter 'pricing_component_value' is set
        if ('pricing_component_value' not in params) or (params['pricing_component_value'] is None):
            raise ValueError("Missing the required parameter `pricing_component_value` when calling `set_pricing_component_value_on_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/pricing-component-values'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pricing_component_value' in params:
            body_params = params['pricing_component_value']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PricingComponentValuePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def set_pricing_component_value_on_subscription_v2(self, subscription_id, pricing_component, value, **kwargs):
        """
        Upgrades/downgrades this subscription to some new value for the specified pricing-component.
        {\"nickname\":\"Set value\",\"request\":\"setPricingComponentValueRequest.html\",\"response\":\"setPricingComponentValue.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_pricing_component_value_on_subscription_v2(subscription_id, pricing_component, value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str pricing_component: Name or ID of the pricing-component. (required)
        :param PricingComponentValueRequest value: The pricing-component-value request (required)
        :return: PricingComponentValueResponsePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_pricing_component_value_on_subscription_v2_with_http_info(subscription_id, pricing_component, value, **kwargs)
        else:
            (data) = self.set_pricing_component_value_on_subscription_v2_with_http_info(subscription_id, pricing_component, value, **kwargs)
            return data

    def set_pricing_component_value_on_subscription_v2_with_http_info(self, subscription_id, pricing_component, value, **kwargs):
        """
        Upgrades/downgrades this subscription to some new value for the specified pricing-component.
        {\"nickname\":\"Set value\",\"request\":\"setPricingComponentValueRequest.html\",\"response\":\"setPricingComponentValue.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_pricing_component_value_on_subscription_v2_with_http_info(subscription_id, pricing_component, value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str subscription_id:  (required)
        :param str pricing_component: Name or ID of the pricing-component. (required)
        :param PricingComponentValueRequest value: The pricing-component-value request (required)
        :return: PricingComponentValueResponsePagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription_id', 'pricing_component', 'value']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_pricing_component_value_on_subscription_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `set_pricing_component_value_on_subscription_v2`")
        # verify the required parameter 'pricing_component' is set
        if ('pricing_component' not in params) or (params['pricing_component'] is None):
            raise ValueError("Missing the required parameter `pricing_component` when calling `set_pricing_component_value_on_subscription_v2`")
        # verify the required parameter 'value' is set
        if ('value' not in params) or (params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `set_pricing_component_value_on_subscription_v2`")

        resource_path = '/subscriptions/{subscription-ID}/values/{pricing-component}'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']
        if 'pricing_component' in params:
            path_params['pricing-component'] = params['pricing_component']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'value' in params:
            body_params = params['value']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='PricingComponentValueResponsePagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_subscription(self, subscription, **kwargs):
        """
        Update a subscription.
        {\"nickname\":\"Update a subscription\",\"request\":\"updateSubscriptionRequest.html\",\"response\":\"updateSubscriptionResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_subscription(subscription, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Subscription subscription: The subscription object to be updated. (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_subscription_with_http_info(subscription, **kwargs)
        else:
            (data) = self.update_subscription_with_http_info(subscription, **kwargs)
            return data

    def update_subscription_with_http_info(self, subscription, **kwargs):
        """
        Update a subscription.
        {\"nickname\":\"Update a subscription\",\"request\":\"updateSubscriptionRequest.html\",\"response\":\"updateSubscriptionResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_subscription_with_http_info(subscription, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Subscription subscription: The subscription object to be updated. (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['subscription']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'subscription' is set
        if ('subscription' not in params) or (params['subscription'] is None):
            raise ValueError("Missing the required parameter `subscription` when calling `update_subscription`")

        resource_path = '/subscriptions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'subscription' in params:
            body_params = params['subscription']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/xml', 'application/xml', 'application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def update_subscription_v2(self, request, **kwargs):
        """
        Update a subscription (V2).
        {\"nickname\":\"Update subscription (V2)\",\"response\":\"updateSubscriptionViaHelper.html\",\"request\":\"updateSubscriptionViaHelper.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_subscription_v2(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UpdateSubscriptionRequest request:  (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_subscription_v2_with_http_info(request, **kwargs)
        else:
            (data) = self.update_subscription_v2_with_http_info(request, **kwargs)
            return data

    def update_subscription_v2_with_http_info(self, request, **kwargs):
        """
        Update a subscription (V2).
        {\"nickname\":\"Update subscription (V2)\",\"response\":\"updateSubscriptionViaHelper.html\",\"request\":\"updateSubscriptionViaHelper.request.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_subscription_v2_with_http_info(request, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UpdateSubscriptionRequest request:  (required)
        :return: SubscriptionPagedMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_subscription_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'request' is set
        if ('request' not in params) or (params['request'] is None):
            raise ValueError("Missing the required parameter `request` when calling `update_subscription_v2`")

        resource_path = '/subscriptions/update'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request' in params:
            body_params = params['request']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='SubscriptionPagedMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def upsert_metadata_for_subscription(self, metadata, subscription_id, **kwargs):
        """
        Update any existing metadata key-values and insert any new key-values, no keys will be removed.
        {\"nickname\":\"Upsert on subscription\",\"request\":\"upsertSubscriptionMetadataRequest.html\",\"response\":\"upsertSubscriptionMetadataResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upsert_metadata_for_subscription(metadata, subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DynamicMetadata metadata:  (required)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: DynamicMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upsert_metadata_for_subscription_with_http_info(metadata, subscription_id, **kwargs)
        else:
            (data) = self.upsert_metadata_for_subscription_with_http_info(metadata, subscription_id, **kwargs)
            return data

    def upsert_metadata_for_subscription_with_http_info(self, metadata, subscription_id, **kwargs):
        """
        Update any existing metadata key-values and insert any new key-values, no keys will be removed.
        {\"nickname\":\"Upsert on subscription\",\"request\":\"upsertSubscriptionMetadataRequest.html\",\"response\":\"upsertSubscriptionMetadataResponse.html\"}

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upsert_metadata_for_subscription_with_http_info(metadata, subscription_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param DynamicMetadata metadata:  (required)
        :param str subscription_id:  (required)
        :param list[str] organizations: A list of organization-IDs used to restrict the scope of API calls.
        :return: DynamicMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['metadata', 'subscription_id', 'organizations']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_metadata_for_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'metadata' is set
        if ('metadata' not in params) or (params['metadata'] is None):
            raise ValueError("Missing the required parameter `metadata` when calling `upsert_metadata_for_subscription`")
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params) or (params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `upsert_metadata_for_subscription`")

        resource_path = '/subscriptions/{subscription-ID}/metadata'.replace('{format}', 'json')
        path_params = {}
        if 'subscription_id' in params:
            path_params['subscription-ID'] = params['subscription_id']

        query_params = {}
        if 'organizations' in params:
            query_params['organizations'] = params['organizations']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'metadata' in params:
            body_params = params['metadata']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='DynamicMetadata',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))
