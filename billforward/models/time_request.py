# coding: utf-8

"""
    BillForward REST API


    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from pprint import pformat
from six import iteritems
import re


class TimeRequest(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """
    def __init__(self, created=None, periods=None, to=None, dry_run=False, skip_intermediate_periods=False, handle_amendments=False, execution_strategy=None, freeze_on_completion=False, advance_inclusively=False):
        """
        TimeRequest - a model defined in Swagger

        :param dict swaggerTypes: The key is attribute name
                                  and the value is attribute type.
        :param dict attributeMap: The key is attribute name
                                  and the value is json key in definition.
        """
        self.swagger_types = {
            'created': 'datetime',
            'periods': 'int',
            'to': 'datetime',
            'dry_run': 'bool',
            'skip_intermediate_periods': 'bool',
            'handle_amendments': 'bool',
            'execution_strategy': 'str',
            'freeze_on_completion': 'bool',
            'advance_inclusively': 'bool'
        }

        self.attribute_map = {
            'created': 'created',
            'periods': 'periods',
            'to': 'to',
            'dry_run': 'dryRun',
            'skip_intermediate_periods': 'skipIntermediatePeriods',
            'handle_amendments': 'handleAmendments',
            'execution_strategy': 'executionStrategy',
            'freeze_on_completion': 'freezeOnCompletion',
            'advance_inclusively': 'advanceInclusively'
        }

        self._created = created
        self._periods = periods
        self._to = to
        self._dry_run = dry_run
        self._skip_intermediate_periods = skip_intermediate_periods
        self._handle_amendments = handle_amendments
        self._execution_strategy = execution_strategy
        self._freeze_on_completion = freeze_on_completion
        self._advance_inclusively = advance_inclusively

    @property
    def created(self):
        """
        Gets the created of this TimeRequest.
        { \"description\" : \"The UTC DateTime when the object was created.\", \"verbs\":[] }

        :return: The created of this TimeRequest.
        :rtype: datetime
        """
        return self._created

    @created.setter
    def created(self, created):
        """
        Sets the created of this TimeRequest.
        { \"description\" : \"The UTC DateTime when the object was created.\", \"verbs\":[] }

        :param created: The created of this TimeRequest.
        :type: datetime
        """

        self._created = created

    @property
    def periods(self):
        """
        Gets the periods of this TimeRequest.
        {\"description\":\"(Required: one of [`periods`, `to`])<br>The number of period boundaries up to which the subscription should advance. A 1-value advances the subscription to the end of its current service period. Higher values advance the subscription to subsequent period boundaries.\"verbs\":[\"POST\",\"GET\"]}

        :return: The periods of this TimeRequest.
        :rtype: int
        """
        return self._periods

    @periods.setter
    def periods(self, periods):
        """
        Sets the periods of this TimeRequest.
        {\"description\":\"(Required: one of [`periods`, `to`])<br>The number of period boundaries up to which the subscription should advance. A 1-value advances the subscription to the end of its current service period. Higher values advance the subscription to subsequent period boundaries.\"verbs\":[\"POST\",\"GET\"]}

        :param periods: The periods of this TimeRequest.
        :type: int
        """

        self._periods = periods

    @property
    def to(self):
        """
        Gets the to of this TimeRequest.
        {\"description\":\"(Required: one of [`periods`, `to`])<br>The time up until which the subscription should be fast-forwarded.\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The to of this TimeRequest.
        :rtype: datetime
        """
        return self._to

    @to.setter
    def to(self, to):
        """
        Sets the to of this TimeRequest.
        {\"description\":\"(Required: one of [`periods`, `to`])<br>The time up until which the subscription should be fast-forwarded.\",\"verbs\":[\"POST\",\"GET\"]}

        :param to: The to of this TimeRequest.
        :type: datetime
        """

        self._to = to

    @property
    def dry_run(self):
        """
        Gets the dry_run of this TimeRequest.
        {\"default\":false,\"description\":\"Changes described in the response:<br><span class=\\\"label label-default\\\">true</span> &mdash; Are not actually performed; your subscription remains unchanged, no billing events run, and no invoices are executed.<br><span class=\\\"label label-default\\\">false</span> &mdash; Are actually performed and committed.\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The dry_run of this TimeRequest.
        :rtype: bool
        """
        return self._dry_run

    @dry_run.setter
    def dry_run(self, dry_run):
        """
        Sets the dry_run of this TimeRequest.
        {\"default\":false,\"description\":\"Changes described in the response:<br><span class=\\\"label label-default\\\">true</span> &mdash; Are not actually performed; your subscription remains unchanged, no billing events run, and no invoices are executed.<br><span class=\\\"label label-default\\\">false</span> &mdash; Are actually performed and committed.\",\"verbs\":[\"POST\",\"GET\"]}

        :param dry_run: The dry_run of this TimeRequest.
        :type: bool
        """

        self._dry_run = dry_run

    @property
    def skip_intermediate_periods(self):
        """
        Gets the skip_intermediate_periods of this TimeRequest.
        {\"default\":false,\"description\":\"As time scrubs forward:<br><span class=\\\"label label-default\\\">true</span> &mdash; Raise no invoice upon advancing over a period boundary.<br><span class=\\\"label label-default\\\">false</span> &mdash; Raise invoices for any period that is entered.\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The skip_intermediate_periods of this TimeRequest.
        :rtype: bool
        """
        return self._skip_intermediate_periods

    @skip_intermediate_periods.setter
    def skip_intermediate_periods(self, skip_intermediate_periods):
        """
        Sets the skip_intermediate_periods of this TimeRequest.
        {\"default\":false,\"description\":\"As time scrubs forward:<br><span class=\\\"label label-default\\\">true</span> &mdash; Raise no invoice upon advancing over a period boundary.<br><span class=\\\"label label-default\\\">false</span> &mdash; Raise invoices for any period that is entered.\",\"verbs\":[\"POST\",\"GET\"]}

        :param skip_intermediate_periods: The skip_intermediate_periods of this TimeRequest.
        :type: bool
        """

        self._skip_intermediate_periods = skip_intermediate_periods

    @property
    def handle_amendments(self):
        """
        Gets the handle_amendments of this TimeRequest.
        {\"default\":true,\"description\":\"As time scrubs forward:<br><span class=\\\"label label-default\\\">true</span> &mdash; Run any amendments that were scheduled to action.<br><span class=\\\"label label-default\\\">false</span> &mdash; Do not run any amendments that were scheduled to action.\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The handle_amendments of this TimeRequest.
        :rtype: bool
        """
        return self._handle_amendments

    @handle_amendments.setter
    def handle_amendments(self, handle_amendments):
        """
        Sets the handle_amendments of this TimeRequest.
        {\"default\":true,\"description\":\"As time scrubs forward:<br><span class=\\\"label label-default\\\">true</span> &mdash; Run any amendments that were scheduled to action.<br><span class=\\\"label label-default\\\">false</span> &mdash; Do not run any amendments that were scheduled to action.\",\"verbs\":[\"POST\",\"GET\"]}

        :param handle_amendments: The handle_amendments of this TimeRequest.
        :type: bool
        """

        self._handle_amendments = handle_amendments

    @property
    def execution_strategy(self):
        """
        Gets the execution_strategy of this TimeRequest.
        {\"default\":\"<span class=\\\"label label-default\\\">SingleAttempt</span>\",\"description\":\"What strategy to use when executing any invoices raised as time advances:<br><span class=\\\"label label-default\\\">SingleAttempt</span> &mdash; Execute any invoice just once.<br><span class=\\\"label label-default\\\">FollowDunning</span> &mdash; Apply the existing dunning strategy when executing invoices.<br><span class=\\\"label label-default\\\">None</span>: Do not execute invoices.\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The execution_strategy of this TimeRequest.
        :rtype: str
        """
        return self._execution_strategy

    @execution_strategy.setter
    def execution_strategy(self, execution_strategy):
        """
        Sets the execution_strategy of this TimeRequest.
        {\"default\":\"<span class=\\\"label label-default\\\">SingleAttempt</span>\",\"description\":\"What strategy to use when executing any invoices raised as time advances:<br><span class=\\\"label label-default\\\">SingleAttempt</span> &mdash; Execute any invoice just once.<br><span class=\\\"label label-default\\\">FollowDunning</span> &mdash; Apply the existing dunning strategy when executing invoices.<br><span class=\\\"label label-default\\\">None</span>: Do not execute invoices.\",\"verbs\":[\"POST\",\"GET\"]}

        :param execution_strategy: The execution_strategy of this TimeRequest.
        :type: str
        """
        allowed_values = ["SingleAttempt", "FollowDunning", "None"]
        if execution_strategy not in allowed_values:
            raise ValueError(
                "Invalid value for `execution_strategy` ({0}), must be one of {1}"
                .format(execution_strategy, allowed_values)
            )

        self._execution_strategy = execution_strategy

    @property
    def freeze_on_completion(self):
        """
        Gets the freeze_on_completion of this TimeRequest.
        {\"default\":false,\"description\":\"Once the subscription is advanced through time:<br><span class=\\\"label label-default\\\">true</span> &mdash; Freeze the subscription.<br><span class=\\\"label label-default\\\">false</span> &mdash; Do not freeze the subscription.\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The freeze_on_completion of this TimeRequest.
        :rtype: bool
        """
        return self._freeze_on_completion

    @freeze_on_completion.setter
    def freeze_on_completion(self, freeze_on_completion):
        """
        Sets the freeze_on_completion of this TimeRequest.
        {\"default\":false,\"description\":\"Once the subscription is advanced through time:<br><span class=\\\"label label-default\\\">true</span> &mdash; Freeze the subscription.<br><span class=\\\"label label-default\\\">false</span> &mdash; Do not freeze the subscription.\",\"verbs\":[\"POST\",\"GET\"]}

        :param freeze_on_completion: The freeze_on_completion of this TimeRequest.
        :type: bool
        """

        self._freeze_on_completion = freeze_on_completion

    @property
    def advance_inclusively(self):
        """
        Gets the advance_inclusively of this TimeRequest.
        {\"default\":true,\"description\":\"When advancing onto an instant in time:<br><span class=\\\"label label-default\\\">true</span> &mdash; Action the events scheduled for your destination time. Amendments scheduled at your destined time will be actioned during this time travel. Advancing to a period boundary will promote your subscription to the period on the future side of that boundary.<br><span class=\\\"label label-default\\\">false</span> &mdash; Do not action events scheduled for your destination time. Amendments scheduled at your destined time will not be actioned during this time travel. Advancing to a period boundary will result in your subscription's remaining within the period on the past side of that boundary.\",\"verbs\":[\"POST\",\"GET\"]}

        :return: The advance_inclusively of this TimeRequest.
        :rtype: bool
        """
        return self._advance_inclusively

    @advance_inclusively.setter
    def advance_inclusively(self, advance_inclusively):
        """
        Sets the advance_inclusively of this TimeRequest.
        {\"default\":true,\"description\":\"When advancing onto an instant in time:<br><span class=\\\"label label-default\\\">true</span> &mdash; Action the events scheduled for your destination time. Amendments scheduled at your destined time will be actioned during this time travel. Advancing to a period boundary will promote your subscription to the period on the future side of that boundary.<br><span class=\\\"label label-default\\\">false</span> &mdash; Do not action events scheduled for your destination time. Amendments scheduled at your destined time will not be actioned during this time travel. Advancing to a period boundary will result in your subscription's remaining within the period on the past side of that boundary.\",\"verbs\":[\"POST\",\"GET\"]}

        :param advance_inclusively: The advance_inclusively of this TimeRequest.
        :type: bool
        """

        self._advance_inclusively = advance_inclusively

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        return self.to_str()

    def __eq__(self, other):
        """
        Returns true if both objects are equal
        """
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """
        Returns true if both objects are not equal
        """
        return not self == other
